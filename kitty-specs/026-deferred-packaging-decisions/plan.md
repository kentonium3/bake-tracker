# Implementation Plan: Deferred Packaging Decisions

**Branch**: `026-deferred-packaging-decisions` | **Date**: 2025-12-21 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/kitty-specs/026-deferred-packaging-decisions/spec.md`

## Summary

Enable bakers to plan events with generic packaging requirements (e.g., "Cellophane Bags 6x10") instead of committing to specific designs. Users select generic products at planning time with inventory summaries and estimated costs, then assign specific materials from inventory when ready to assemble. Implementation leverages existing `product_name` field for grouping and extends Composition model with `is_generic` flag plus new CompositionAssignment junction table.

## Technical Context

**Language/Version**: Python 3.10+
**Primary Dependencies**: CustomTkinter, SQLAlchemy 2.x
**Storage**: SQLite with WAL mode
**Testing**: pytest
**Target Platform**: Desktop (Windows/macOS/Linux)
**Project Type**: Single desktop application
**Performance Goals**: UI operations complete in <200ms
**Constraints**: Single-user, offline-capable
**Scale/Scope**: ~500 products, ~50 events, ~200 compositions

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. User-Centric Design | PASS | Validated with primary user (Marianne) per design doc |
| II. Data Integrity & FIFO | PASS | Assignment tracks specific inventory items for accurate costing |
| III. Future-Proof Schema | PASS | Additive changes only, no breaking migrations |
| IV. Test-Driven Development | PASS | Unit tests planned for all service methods |
| V. Layered Architecture | PASS | Business logic in services, UI in ui/ |
| VI. Schema Change Strategy | PASS | Export/reset/import cycle for schema changes |
| VII. Pragmatic Aspiration | PASS | Web migration cost: LOW (services are UI-independent) |

## Project Structure

### Documentation (this feature)

```
kitty-specs/026-deferred-packaging-decisions/
├── spec.md              # Feature specification
├── plan.md              # This file
├── research.md          # Research findings
├── data-model.md        # Schema documentation
├── checklists/
│   └── requirements.md  # Spec quality checklist
└── tasks.md             # Task tracking (generated by /spec-kitty.tasks)
```

### Source Code (repository root)

```
src/
├── models/
│   ├── composition.py           # MODIFY: Add is_generic column
│   └── composition_assignment.py # NEW: Junction table model
├── services/
│   ├── packaging_service.py     # NEW: Generic packaging operations
│   ├── composition_service.py   # MODIFY: Support generic requirements
│   ├── assembly_service.py      # MODIFY: Validate assignments at completion
│   └── shopping_list_service.py # MODIFY: Group by product_name
├── ui/
│   ├── composition_editor.py    # MODIFY: Generic/specific toggle
│   ├── assembly_screen.py       # MODIFY: Assignment interface
│   ├── dashboard.py             # MODIFY: Pending indicators
│   └── packaging_assignment_dialog.py # NEW: Material assignment UI
└── tests/
    └── services/
        └── test_packaging_service.py # NEW: Service tests
```

**Structure Decision**: Single project layout following existing codebase conventions.

## Complexity Tracking

*No constitution violations identified.*

## Implementation Phases

### Phase 1: Schema & Models (Foundation)

**Goal**: Database schema changes and model definitions.

**Tasks**:
1. Add `is_generic` column to Composition model
2. Create CompositionAssignment model
3. Update model `__init__.py` exports
4. Create schema migration via export/reset/import

**Dependencies**: None
**Risk**: Low - additive schema changes only

### Phase 2: Service Layer (Core Logic)

**Goal**: Business logic for generic packaging operations.

**Tasks**:
1. Create `packaging_service.py` with:
   - `get_generic_products()` - list available generic product types
   - `get_generic_inventory_summary(product_name)` - total + breakdown
   - `get_estimated_cost(product_name, quantity)` - average price calculation
   - `create_generic_requirement()` - set up generic composition
   - `assign_materials()` - create assignment records
   - `get_pending_requirements()` - find unassigned generics
   - `is_fully_assigned()` - check assignment status

2. Update `composition_service.py`:
   - Support `is_generic` flag in create/update
   - Add assignment retrieval methods

3. Update `assembly_service.py`:
   - Add `check_packaging_assigned()` validation
   - Support bypass flag for assembly without assignment

4. Update `shopping_list_service.py`:
   - Group generic packaging by `product_name`
   - Use estimated costs for unassigned items

**Dependencies**: Phase 1
**Risk**: Medium - cost calculation accuracy critical

### Phase 3: UI - Planning (User Story 1)

**Goal**: Enable generic packaging selection during event planning.

**Tasks**:
1. Add radio button toggle: "Specific material" / "Generic product"
2. Create generic product dropdown (distinct `product_name` values)
3. Add inventory summary widget showing total and breakdown
4. Display estimated cost with "Estimated" label
5. Persist `is_generic=True` when saving

**Dependencies**: Phase 2
**Risk**: Low - extends existing UI patterns

### Phase 4: UI - Assignment (User Story 2)

**Goal**: Material assignment interface for generic requirements.

**Tasks**:
1. Create `PackagingAssignmentDialog`:
   - Show available specific products for the generic type
   - Checkbox + quantity input for each product
   - Running total: "Assigned: X / Y needed"
   - Validation before save
2. Integrate dialog into assembly screen
3. Update cost display after assignment

**Dependencies**: Phase 2, Phase 3
**Risk**: Medium - quantity validation UX critical

### Phase 5: UI - Dashboard & Indicators (User Story 3)

**Goal**: Visual indicators for pending packaging decisions.

**Tasks**:
1. Add pending indicator icon to dashboard items
2. Make indicators clickable (navigate to assignment)
3. Add tooltip: "Packaging needs selection"
4. Filter option to show only pending items

**Dependencies**: Phase 2
**Risk**: Low - display only

### Phase 6: Shopping List (User Story 4)

**Goal**: Generic packaging representation in shopping lists.

**Tasks**:
1. Update shopping list generation to group by `product_name`
2. Display as "Cellophane Bags 6x10: 50 needed"
3. Show estimated costs with label

**Dependencies**: Phase 2
**Risk**: Low - read-only display

### Phase 7: Assembly Enforcement (User Story 5)

**Goal**: Prompt about unassigned packaging at assembly completion.

**Tasks**:
1. Add check in assembly completion flow
2. Create prompt dialog with options:
   - "Quick Assign" - open assignment dialog
   - "Assembly Details" - navigate to full screen
   - "Record Assembly Anyway" - bypass with flag
3. Flag event for reconciliation if bypassed

**Dependencies**: Phase 4
**Risk**: Low - extends existing assembly flow

### Phase 8: BOM Modification (User Story 6)

**Goal**: Allow packaging changes during assembly.

**Tasks**:
1. Enable add/remove of packaging in assembly definition
2. Clear previous assignments when requirements change
3. Recalculate costs and availability
4. Warn if changes affect other productions

**Dependencies**: Phase 4
**Risk**: Medium - state management complexity

### Phase 9: Testing & Polish

**Goal**: Comprehensive testing and refinement.

**Tasks**:
1. Unit tests for packaging_service (>80% coverage)
2. Integration tests for full workflow
3. Edge case testing (shortage, re-assignment, bypass)
4. User acceptance testing with primary user
5. Update import/export for new fields

**Dependencies**: All previous phases
**Risk**: Low

## Test Strategy

### Unit Tests (Phase 2)

```python
# test_packaging_service.py

def test_get_generic_inventory_summary():
    """Total quantity and breakdown by brand."""

def test_get_estimated_cost():
    """Average price across products."""

def test_assign_materials_validates_quantity():
    """Sum must equal required."""

def test_assign_materials_validates_availability():
    """Cannot exceed inventory."""

def test_is_fully_assigned():
    """True when assignments complete."""
```

### Integration Tests (Phase 9)

```python
def test_plan_with_generic_then_assign():
    """Full workflow: plan → assign → verify costs."""

def test_shopping_list_with_generics():
    """Generic items appear as product types."""

def test_assembly_bypass_flags_event():
    """Bypass records flag for reconciliation."""
```

## Risk Mitigation

| Risk | Mitigation |
|------|------------|
| Cost calculation accuracy | Use same costing logic as existing FIFO system |
| UI complexity | Incremental delivery, user testing after each phase |
| Assignment validation UX | Clear running total, prevent invalid saves |
| Backward compatibility | Default `is_generic=False`, existing data unchanged |

## Definition of Done

- [ ] All user stories implemented and passing acceptance criteria
- [ ] Unit test coverage >70% for new service code
- [ ] Integration tests for complete workflows
- [ ] User acceptance testing completed with primary user
- [ ] Import/export supports new fields
- [ ] Documentation updated (CLAUDE.md if needed)
- [ ] No regressions in existing functionality
