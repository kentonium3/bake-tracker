# Implementation Plan: Dual-Yield Recipe Output Support

**Branch**: `083-dual-yield-recipe-output-support` | **Date**: 2026-01-29 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `kitty-specs/083-dual-yield-recipe-output-support/spec.md`

## Summary

Add `yield_type` field ('EA' or 'SERVING') to FinishedUnit model, enabling recipes to classify output yields as whole units (EA) or servings (SERVING). This supports planning services that need to distinguish between delivery quantities and consumption planning.

**Key changes**:
- Add `yield_type` column to FinishedUnit with CHECK constraint
- Add UNIQUE constraint on (recipe_id, item_unit, yield_type)
- Update export/import to include yield_type
- Update Recipe UI to show/edit yield_type dropdown
- Migrate existing data with default yield_type='SERVING'

## Technical Context

**Language/Version**: Python 3.10+
**Primary Dependencies**: SQLAlchemy 2.x, CustomTkinter
**Storage**: SQLite with WAL mode
**Testing**: pytest
**Target Platform**: Desktop (Windows/macOS/Linux)
**Project Type**: Single desktop application
**Performance Goals**: N/A (desktop app, single user)
**Constraints**: Must follow constitutional schema change workflow (export → reset → import)
**Scale/Scope**: Single user, <1000 recipes

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. User-Centric Design | ✅ PASS | Solves real planning problem; UI remains simple |
| II. Data Integrity & FIFO | ✅ PASS | No impact on FIFO; adds validation constraints |
| III. Future-Proof Schema | ✅ PASS | yield_type supports future planning module |
| IV. Test-Driven Development | ✅ PASS | Will add tests for service validation |
| V. Layered Architecture | ✅ PASS | Changes follow UI → Service → Model pattern |
| VI. Schema Change Strategy | ✅ PASS | Uses export → reset → import workflow |
| VII. Pragmatic Aspiration | ✅ PASS | Supports planning without over-engineering |

**Desktop Phase Checks**:
- Does this design block web deployment? → NO
- Is the service layer UI-independent? → YES
- Does this support AI-assisted JSON import? → YES
- Web migration cost? → LOW (schema change only)

## Project Structure

### Documentation (this feature)

```
kitty-specs/083-dual-yield-recipe-output-support/
├── spec.md              # Feature specification
├── plan.md              # This file
├── research.md          # Research findings
├── data-model.md        # Schema changes
├── checklists/          # Quality checklists
│   └── requirements.md
└── tasks/               # Work packages (generated by /spec-kitty.tasks)
```

### Source Code (files to modify)

```
src/
├── models/
│   └── finished_unit.py      # Add yield_type column and constraints
├── services/
│   ├── recipe_service.py     # Add yield_type validation
│   └── coordinated_export_service.py  # Update export/import
├── ui/
│   ├── forms/
│   │   └── recipe_form.py    # Add yield_type dropdown to YieldTypeRow
│   └── recipes_tab.py        # Update display logic
└── tests/
    └── services/
        └── test_finished_unit_yield_type.py  # New test file
```

**Structure Decision**: Single desktop application with existing layered architecture. All changes fit within established patterns.

## Complexity Tracking

*No constitution violations - table intentionally empty*

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| - | - | - |

## Parallel Work Analysis

### Dependency Graph

```
WP01: Model (schema)
    │
    ├──> WP02: Service Layer (depends on model)
    │         │
    │         ├──> WP03: Export/Import (depends on service)
    │         │
    │         └──> WP04: UI (depends on service)
    │
    └──> WP05: Migration (depends on model + export/import)
```

### Work Distribution

- **Sequential work (WP01)**: Model changes must be complete before service/UI work
- **Parallel streams**: After WP01 completes:
  - Stream A: WP02 → WP03 (service + export/import)
  - Stream B: WP02 → WP04 (service + UI)
- **Final integration (WP05)**: Migration after all code changes complete

### Agent Assignments (if parallelizing)

| Work Package | Owner | Files |
|--------------|-------|-------|
| WP01: Model | Lead Agent | `src/models/finished_unit.py` |
| WP02: Service | Lead Agent | `src/services/recipe_service.py`, tests |
| WP03: Export/Import | Teammate (Gemini) | `src/services/coordinated_export_service.py` |
| WP04: UI | Teammate (Gemini) | `src/ui/forms/recipe_form.py`, `src/ui/recipes_tab.py` |
| WP05: Migration | Lead Agent | Migration script, integration test |

### Coordination Points

- **After WP01**: Verify model tests pass before parallel work begins
- **After WP02-04**: Integration test with all components
- **After WP05**: Full export → reset → import cycle test

## Implementation Approach

### Phase 1: Model Layer (WP01)

1. Add `yield_type` column to FinishedUnit model
2. Add CHECK constraint for valid values ('EA', 'SERVING')
3. Add UNIQUE constraint on (recipe_id, item_unit, yield_type)
4. Add index on yield_type for query performance
5. Write model-level unit tests

### Phase 2: Service Layer (WP02)

1. Add `validate_yield_type()` function to recipe_service
2. Update finished_unit creation/update to validate yield_type
3. Write service-level unit tests

### Phase 3: Export/Import (WP03)

1. Update export to include yield_type field
2. Update import to read yield_type with default='SERVING'
3. Add import validation for yield_type values
4. Write export/import round-trip tests

### Phase 4: UI Layer (WP04)

1. Add yield_type dropdown to YieldTypeRow component
2. Update column headers to include "Type"
3. Update form validation for yield_type
4. Update recipe detail display to show yield_type
5. Write UI integration tests (if applicable)

### Phase 5: Migration (WP05)

1. Create migration script to transform existing export data
2. Document migration procedure
3. Test full export → transform → import cycle
4. Verify no data loss

## Risk Mitigation

| Risk | Mitigation |
|------|------------|
| UNIQUE constraint rejects existing data | Migration adds yield_type='SERVING' to all, ensuring uniqueness |
| Backward compatibility with old exports | Import defaults missing yield_type to 'SERVING' |
| UI complexity increases | yield_type dropdown is single additional field, minimal impact |

## Definition of Done

- [ ] All model tests pass
- [ ] All service tests pass
- [ ] Export/import round-trip preserves yield_type
- [ ] UI displays and edits yield_type correctly
- [ ] Migration transforms existing data correctly
- [ ] No data loss after migration
- [ ] Code follows existing patterns (no new abstractions)
