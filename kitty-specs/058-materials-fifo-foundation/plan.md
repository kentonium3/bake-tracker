# Implementation Plan: Materials FIFO Foundation

**Branch**: `058-materials-fifo-foundation` | **Date**: 2026-01-18 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/kitty-specs/058-materials-fifo-foundation/spec.md`

## Summary

Bring the materials domain into constitutional compliance by implementing FIFO inventory tracking that exactly parallels the food/ingredients system. This involves creating MaterialInventoryItem table, removing cost/inventory from MaterialProduct (definition layer), building MaterialInventoryService with FIFO primitives, implementing metric base unit conversion, and updating import/export.

**Breaking Change**: Fresh start for material inventory - no migration of existing MaterialPurchase data.

## Technical Context

**Language/Version**: Python 3.10+ (existing codebase)
**Primary Dependencies**: SQLAlchemy 2.x, CustomTkinter (UI updates minimal)
**Storage**: SQLite with WAL mode (existing database)
**Testing**: pytest (>70% service layer coverage required)
**Target Platform**: Desktop (Windows/macOS/Linux)
**Project Type**: Single desktop application
**Performance Goals**: N/A (desktop app, local database)
**Constraints**: Must exactly parallel ingredient FIFO pattern for constitutional compliance
**Scale/Scope**: Single user, ~100s of material products

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| **I. User-Centric Design** | PASS | Removes manual cost tracking complexity; FIFO matches natural consumption |
| **II. Data Integrity & FIFO** | PASS | Implements FIFO for materials (currently missing); aligns with ingredients |
| **III. Future-Proof Schema** | PASS | MaterialInventoryItem adds capability without breaking existing patterns |
| **IV. Test-Driven Development** | PASS | Service layer will have >70% coverage; FIFO algorithm unit tested |
| **V. Layered Architecture** | PASS | Services layer separated; UI updates minimal |
| **VI. Schema Change Strategy** | PASS | Export → reset → import cycle for schema migration |
| **VII. Pragmatic Aspiration** | PASS | Parallels proven ingredient pattern; supports future AI-assisted inventory |

**No violations requiring justification.**

## Project Structure

### Documentation (this feature)

```
kitty-specs/058-materials-fifo-foundation/
├── spec.md              # Feature specification
├── plan.md              # This file
├── research.md          # Pattern research findings
├── data-model.md        # MaterialInventoryItem schema
├── checklists/          # Quality checklists
└── tasks/               # Work packages (generated by /spec-kitty.tasks)
```

### Source Code (repository root)

```
src/
├── models/
│   ├── material_product.py      # MODIFY: Remove current_inventory, weighted_avg_cost
│   ├── material_inventory_item.py  # NEW: FIFO inventory tracking
│   ├── material_consumption.py  # MODIFY: Add inventory_item_id FK
│   └── material.py              # MODIFY: base_unit_type values
├── services/
│   ├── material_inventory_service.py  # NEW: FIFO primitives
│   ├── material_consumption_service.py  # NEW: Consumption records
│   ├── material_catalog_service.py  # MODIFY: Remove cost/inventory logic
│   ├── material_purchase_service.py  # MODIFY: Create inventory items
│   ├── material_unit_converter.py  # NEW: Imperial/metric conversion
│   └── import_export_service.py  # MODIFY: Schema field handling
├── ui/
│   └── materials_tab.py         # MODIFY: Remove cost/inventory columns
└── tests/
    ├── test_material_inventory_service.py  # NEW
    ├── test_material_consumption_service.py  # NEW
    ├── test_material_unit_converter.py  # NEW
    └── test_material_fifo.py  # NEW: Multi-lot FIFO scenarios
```

**Structure Decision**: Single project structure (existing), adding new models and services following established patterns.

## Parallelization Strategy

**Conservative parallelization** - Claude handles core FIFO logic, Gemini handles 1-2 independent packages.

| Work Package | Agent | Dependency | Parallelizable |
|--------------|-------|------------|----------------|
| WP01: Schema Changes | Claude | None | Foundation |
| WP02: Unit Converter | Gemini | None | Yes - independent |
| WP03: MaterialInventoryService | Claude | WP01 | After schema |
| WP04: MaterialConsumptionService | Claude | WP01, WP03 | After inventory service |
| WP05: Import/Export Updates | Gemini | WP01 | Yes - after schema |
| WP06: Catalog UI Updates | Claude | WP01-WP04 | After services |
| WP07: Integration Tests | Claude | All | Final validation |

**Parallel execution windows**:
1. WP01 (Claude) + WP02 (Gemini) - run simultaneously
2. WP03 (Claude) + WP05 (Gemini) - run after WP01 completes
3. WP04, WP06, WP07 - sequential (Claude)

## Key Implementation Patterns

### Pattern 1: InventoryItem → MaterialInventoryItem (Exact Parallel)

```python
# From InventoryItem (ingredients) - COPY THIS EXACTLY
class MaterialInventoryItem(BaseModel):
    __tablename__ = "material_inventory_items"

    material_product_id = Column(Integer, ForeignKey("material_products.id"), nullable=False)
    material_purchase_id = Column(Integer, ForeignKey("material_purchases.id"), nullable=False)

    quantity_purchased = Column(Float, nullable=False)  # Immutable snapshot
    quantity_remaining = Column(Float, nullable=False)  # Mutable, decremented on consume
    cost_per_unit = Column(Numeric(10, 4), nullable=False)  # Immutable snapshot

    purchase_date = Column(Date, nullable=False, index=True)  # For FIFO ordering

    # Relationships
    product = relationship("MaterialProduct", back_populates="inventory_items")
    purchase = relationship("MaterialPurchase", back_populates="inventory_item")
    consumptions = relationship("MaterialConsumption", back_populates="inventory_item")
```

### Pattern 2: consume_fifo Algorithm (From inventory_item_service.py)

```python
def consume_material_fifo(
    material_product_id: int,
    quantity_needed: Decimal,
    target_unit: str,
    context_id: Optional[int] = None,  # e.g., assembly_run_id
    dry_run: bool = False,
    session=None,
) -> Dict[str, Any]:
    """
    FIFO consumption algorithm:
    1. Query lots WHERE material_product_id = X AND quantity_remaining > 0
    2. ORDER BY purchase_date ASC (oldest first)
    3. Iterate, consuming from each lot until quantity satisfied
    4. Create MaterialConsumption record(s) with inventory_item_id
    5. Return breakdown with total_cost
    """
```

### Pattern 3: Unit Conversion (Imperial → Metric Base)

```python
# Conversion factors to cm (base unit)
LINEAR_CONVERSIONS = {
    "feet": 30.48,
    "inches": 2.54,
    "yards": 91.44,
    "meters": 100.0,
    "mm": 0.1,
    "cm": 1.0,  # Base unit
}

AREA_CONVERSIONS = {
    "square_feet": 929.03,
    "square_inches": 6.4516,
    "square_meters": 10000.0,
    "square_cm": 1.0,  # Base unit
}
```

## Risk Mitigations

| Risk | Mitigation |
|------|------------|
| FIFO algorithm complexity | Copy ingredient pattern exactly; comprehensive unit tests |
| Unit conversion errors | Reference authoritative sources; test all conversion factors |
| Pattern drift from ingredients | Continuous reference to ingredient code during implementation |
| Breaking change impact | Clear migration documentation; export catalog before migration |

## Complexity Tracking

*No constitution violations requiring justification.*

| Decision | Rationale |
|----------|-----------|
| New table (MaterialInventoryItem) | Required for FIFO tracking - parallels InventoryItem |
| New services (2) | Required for service layer separation - parallels ingredient services |
| Remove fields from MaterialProduct | Constitutional requirement - definition/instantiation separation |
