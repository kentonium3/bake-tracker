# Implementation Plan: MaterialUnit Schema Refactor

**Branch**: `085-material-unit-schema-refactor` | **Date**: 2026-01-30 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `kitty-specs/085-material-unit-schema-refactor/spec.md`

## Summary

Refactor MaterialUnit to be a child of MaterialProduct (instead of Material) to enable product-specific consumption units. This involves:
1. **Schema Change**: MaterialUnit.material_id → MaterialUnit.material_product_id FK
2. **Auto-generation**: Create "1 {name}" MaterialUnit for package_count products
3. **Composition Cleanup**: Remove material_id from Composition (5-way → 4-way XOR)
4. **UI Updates**: MaterialProduct form sub-section + Units tab detail popup
5. **Export/Import**: Update to use material_product_slug
6. **Migration Script**: Standalone transformation script for export data

## Technical Context

**Language/Version**: Python 3.10+
**Primary Dependencies**: CustomTkinter, SQLAlchemy 2.x, pytest
**Storage**: SQLite with WAL mode
**Testing**: pytest with >80% service coverage target
**Target Platform**: Windows/macOS desktop (PyInstaller distribution)
**Project Type**: Single desktop application
**Performance Goals**: Auto-generation <500ms per product creation
**Constraints**: Export→Reset→Import migration strategy (no live migrations)
**Scale/Scope**: Single user, ~100 materials, ~500 products, ~1000 material units

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| **I. User-Centric Design** | ✅ PASS | Auto-generation reduces toil for majority use case |
| **II. Data Integrity & FIFO** | ✅ PASS | Product-specific units enable accurate inventory tracking |
| **III. Future-Proof Schema** | ✅ PASS | MaterialProduct as parent aligns with web multi-tenant patterns |
| **IV. Test-Driven Development** | ✅ PASS | >80% service coverage required in success criteria |
| **V. Layered Architecture** | ✅ PASS | UI→Services→Models flow maintained |
| **VI. Schema Change Strategy** | ✅ PASS | Export→Reset→Import with standalone transformation script |
| **VII. Pragmatic Aspiration** | ✅ PASS | Desktop today, web-ready architecture |

**Gate Result**: PASS - No violations requiring justification

## Project Structure

### Documentation (this feature)

```
kitty-specs/085-material-unit-schema-refactor/
├── spec.md              # Feature specification
├── plan.md              # This file
├── research.md          # Pattern research findings
├── data-model.md        # Entity changes documentation
├── checklists/          # Validation checklists
│   └── requirements.md
└── tasks/               # Work packages (generated by /spec-kitty.tasks)
```

### Source Code (affected files)

```
src/
├── models/
│   ├── material_unit.py      # FK change: material_id → material_product_id
│   ├── material_product.py   # Add: material_units relationship
│   ├── material.py           # Remove: units relationship
│   └── composition.py        # Remove: material_id, 5-way → 4-way XOR
├── services/
│   ├── material_unit_service.py      # Update: FK references, validation
│   ├── material_product_service.py   # Add: auto-generation on create
│   ├── composition_service.py        # Remove: material_id support
│   ├── import_export_service.py      # Update: material_product_slug export
│   └── catalog_import_service.py     # Update: material_product_slug import
├── ui/
│   ├── tabs/materials_tab.py         # Update: Units sub-tab read-only + popup
│   └── dialogs/                      # Add: MaterialProduct detail popup
└── tests/
    ├── test_material_unit_service.py
    ├── test_material_product_service.py
    ├── test_composition_service.py
    └── test_import_export_service.py

scripts/
└── migrate_material_units.py         # New: Standalone migration transformation
```

**Structure Decision**: Single project, desktop application. All source in `src/`, tests in `src/tests/`, migration script in `scripts/`.

## Parallel Work Analysis

### Dependency Graph

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ Wave 1: Schema Foundation (Sequential - must complete first)                │
│   WP01: MaterialUnit FK change (material_id → material_product_id)          │
│   WP02: Composition material_id removal (5-way → 4-way XOR)                 │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ Wave 2: Service Layer (Parallel after Wave 1)                               │
│   WP03: MaterialUnit service updates (FK validation, queries)    ──┐        │
│   WP04: Auto-generation in MaterialProduct service               ──┼─ parallel
│   WP05: Composition service cleanup                              ──┘        │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ Wave 3: Export/Import & UI (Parallel after Wave 2)                          │
│   WP06: Export/Import updates (material_product_slug)            ──┐        │
│   WP07: MaterialProduct form sub-section UI                      ──┼─ parallel
│   WP08: Units tab read-only + detail popup                       ──┘        │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ Wave 4: Migration (Sequential - depends on export/import)                   │
│   WP09: Migration transformation script                                     │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Work Distribution

- **Sequential work (Wave 1)**: Schema changes must complete before service layer can be updated
- **Parallel streams (Wave 2)**: MaterialUnit service, auto-generation, Composition cleanup are independent
- **Parallel streams (Wave 3)**: Export/import and UI work on different layers
- **Integration (Wave 4)**: Migration script depends on final export format

### Agent Assignments (for parallel execution)

| Work Package | Primary Agent | Files |
|--------------|---------------|-------|
| WP01-WP02 | Lead (Claude) | `src/models/*.py` |
| WP03 | Lead (Claude) | `src/services/material_unit_service.py` |
| WP04 | Gemini | `src/services/material_product_service.py` |
| WP05 | Gemini | `src/services/composition_service.py` |
| WP06 | Lead (Claude) | `src/services/*_import*.py`, `import_export_service.py` |
| WP07 | Gemini | `src/ui/tabs/materials_tab.py` (product form) |
| WP08 | Lead (Claude) | `src/ui/tabs/materials_tab.py` (units tab), `src/ui/dialogs/` |
| WP09 | Lead (Claude) | `scripts/migrate_material_units.py` |

### Coordination Points

- **After Wave 1**: Verify schema tests pass before Wave 2 begins
- **After Wave 2**: Run full service test suite before UI work
- **After Wave 3**: Integration test export→import round-trip
- **After Wave 4**: Full migration test with sample data

## Key Patterns to Follow

### 1. FK Relationship Pattern (from FinishedUnit→Recipe)

```python
# MaterialUnit model
material_product_id = Column(
    Integer,
    ForeignKey("material_products.id", ondelete="CASCADE"),
    nullable=False,
    index=True,
)
material_product = relationship("MaterialProduct", back_populates="material_units", lazy="joined")

# MaterialProduct model
material_units = relationship(
    "MaterialUnit",
    back_populates="material_product",
    cascade="all, delete-orphan",
    lazy="select",
)
```

### 2. Slug Auto-Generation Pattern (from recipe_service.py)

```python
def _generate_material_unit_slug(name: str) -> str:
    """Generate URL-safe slug from name."""
    slug = unicodedata.normalize("NFKD", name)
    slug = slug.encode("ascii", "ignore").decode("ascii")
    slug = slug.lower()
    slug = re.sub(r"[\s_]+", "-", slug)
    slug = re.sub(r"[^a-z0-9-]", "", slug)
    slug = re.sub(r"-+", "-", slug)
    slug = slug.strip("-")
    return slug or "unknown-unit"

def _generate_unique_slug(name: str, session: Session, material_product_id: int) -> str:
    """Generate unique slug within product scope."""
    base_slug = _generate_material_unit_slug(name)
    for attempt in range(1000):
        candidate = base_slug if attempt == 0 else f"{base_slug}-{attempt + 1}"
        existing = session.query(MaterialUnit).filter(
            MaterialUnit.material_product_id == material_product_id,
            MaterialUnit.slug == candidate
        ).first()
        if not existing:
            return candidate
    raise ValidationError(f"Unable to generate unique slug for '{name}'")
```

### 3. XOR Constraint Pattern (4-way, from Composition)

```python
CheckConstraint(
    "(finished_unit_id IS NOT NULL AND finished_good_id IS NULL AND packaging_product_id IS NULL AND material_unit_id IS NULL) OR "
    "(finished_unit_id IS NULL AND finished_good_id IS NOT NULL AND packaging_product_id IS NULL AND material_unit_id IS NULL) OR "
    "(finished_unit_id IS NULL AND finished_good_id IS NULL AND packaging_product_id IS NOT NULL AND material_unit_id IS NULL) OR "
    "(finished_unit_id IS NULL AND finished_good_id IS NULL AND packaging_product_id IS NULL AND material_unit_id IS NOT NULL)",
    name="ck_composition_exactly_one_component",
),
```

### 4. Export/Import FK Resolution Pattern

```python
# Export: Use slug string
export_data["material_units"].append({
    "material_product_slug": unit.material_product.slug,  # FK via slug
    "name": unit.name,
    "slug": unit.slug,
    ...
})

# Import: Resolve slug to ID
product_lookup = {row.slug: row.id for row in session.query(MaterialProduct).all()}
material_product_id = product_lookup.get(item["material_product_slug"])
if material_product_id is None:
    result.add_error(..., f"MaterialProduct '{item['material_product_slug']}' not found")
```

## Planning Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Units tab navigation | Modal/popup | Simpler than accordion; avoids new UI component |
| Migration location | `scripts/migrate_material_units.py` | One-time operation; keeps export service clean |
| Auto-gen editability | Fully editable | User may need to customize after creation |
| Name uniqueness scope | Per-product | Same name allowed across different products |
| Slug uniqueness scope | Per-product | Matches name scope for consistency |
| Composition migration | Skip with log | User fixes externally; cleaner import logic |

## Risk Mitigation

| Risk | Mitigation |
|------|------------|
| Migration creates too many duplicates | Log duplication count; user consolidates products if needed |
| Auto-generation creates unwanted units | Allow deletion if not in use |
| Users confused about which product's unit to select | Show product name in MaterialUnit dropdown |
| Existing Compositions with material_id | Skip with clear log; document manual fix process |

## Next Steps

1. **Run `/spec-kitty.tasks`** to generate work packages from this plan
2. **Wave 1**: Implement schema changes (WP01, WP02)
3. **Wave 2**: Parallel service layer work (WP03-WP05)
4. **Wave 3**: Parallel export/import and UI work (WP06-WP08)
5. **Wave 4**: Migration script (WP09)
6. **Integration**: Full test with sample data export→migrate→import
