# Implementation Plan: Purchases Tab with CRUD Operations

**Branch**: `043-purchases-tab-crud-operations` | **Date**: 2026-01-08 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/kitty-specs/043-purchases-tab-crud-operations/spec.md`

## Summary

Implement a Purchases tab in PURCHASE mode as the primary data entry point for recording purchases. This establishes the correct Purchase → Inventory architectural flow, provides full CRUD operations (Add, Edit, Delete, View Details), and displays purchase history with FIFO-aware remaining inventory tracking.

**Technical Approach**: Extend existing `PurchaseService` with new query/validation methods, create `PurchasesTab` following InventoryTab patterns, and implement three dialogs (Add, Edit, View Details) following AdjustmentDialog patterns.

## Technical Context

**Language/Version**: Python 3.10+
**Primary Dependencies**: CustomTkinter, SQLAlchemy 2.x, ttk.Treeview
**Storage**: SQLite with WAL mode (existing)
**Testing**: pytest with >70% service coverage target
**Target Platform**: Desktop (Windows/macOS/Linux)
**Project Type**: Single desktop application
**Performance Goals**: List loads <1s for 500 purchases, filter updates <500ms
**Constraints**: Session management anti-pattern avoidance (see CLAUDE.md)
**Scale/Scope**: Single user, ~500 purchases typical

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. User-Centric Design | PASS | Primary user workflow validated in design doc; matches real shopping trip patterns |
| II. Data Integrity & FIFO | PASS | Delete blocked if consumed; Edit validates consumed quantity; FIFO tracking in "Remaining" column |
| III. Future-Proof Schema | PASS | No schema changes; reuses existing F028 models |
| IV. Test-Driven Development | PASS | Service methods require unit tests; >70% coverage target |
| V. Layered Architecture | PASS | UI calls services; services handle business logic; no cross-layer violations |
| VI. Schema Change Strategy | N/A | No schema changes |
| VII. Pragmatic Aspiration | PASS | Service layer is API-ready; supports future AI-assisted purchase entry via JSON import |

**Desktop Phase Checks**:
- Does this design block web deployment? **NO** - Service layer is UI-independent
- Is the service layer UI-independent? **YES** - All business logic in PurchaseService
- Does this support AI-assisted JSON import? **YES** - Same Purchase creation path
- Web migration cost? **LOW** - Services become API endpoints directly

## Project Structure

### Documentation (this feature)

```
kitty-specs/043-purchases-tab-crud-operations/
├── spec.md              # Feature specification (complete)
├── plan.md              # This file
├── research.md          # Codebase patterns and decisions
├── data-model.md        # Entity documentation and service contracts
├── quickstart.md        # Implementation quick reference
└── tasks.md             # Generated by /spec-kitty.tasks (NOT this command)
```

### Source Code (repository root)

```
src/
├── models/              # Existing - no changes needed
│   ├── purchase.py      # Purchase model (F028)
│   ├── inventory_item.py # InventoryItem model (F028)
│   └── ...
├── services/
│   └── purchase_service.py  # EXTEND with new methods
├── ui/
│   ├── tabs/
│   │   └── purchases_tab.py # NEW - main tab implementation
│   ├── dialogs/
│   │   ├── add_purchase_dialog.py    # NEW
│   │   ├── edit_purchase_dialog.py   # NEW
│   │   └── purchase_details_dialog.py # NEW
│   └── dashboards/
│       └── purchase_dashboard.py     # MODIFY - add Purchases tab
└── tests/
    ├── unit/
    │   └── test_purchase_service.py  # EXTEND with new tests
    └── integration/
        └── test_purchase_crud.py     # NEW - end-to-end tests
```

**Structure Decision**: Single desktop application following existing patterns. New files integrate into established directory structure.

## Parallelization Strategy

Based on planning discussion, work is split between Claude (lead) and Gemini (parallel):

| Agent | Responsibility | Files | Rationale |
|-------|---------------|-------|-----------|
| **Claude** | Service layer + Tab UI + Add Purchase dialog | `purchase_service.py`, `purchases_tab.py`, `add_purchase_dialog.py`, `purchase_dashboard.py` | Core flow, tightly coupled, needs coordination |
| **Gemini** | Edit Purchase + View Details dialogs | `edit_purchase_dialog.py`, `purchase_details_dialog.py` | Independent secondary features, can work from service contracts |

**Sequencing**:
1. Claude completes service layer extensions first
2. Claude + Gemini work in parallel on UI components
3. Claude handles Tab UI integration
4. Gemini handles Edit + View Details dialogs (after service contracts defined)

## Implementation Phases

### Phase 1: Service Layer Extensions (Claude)

Extend `PurchaseService` with:

| Method | Signature | Purpose |
|--------|-----------|---------|
| `get_purchases_filtered()` | `(date_range: str, supplier_id: Optional[int], search: Optional[str], session: Optional[Session]) -> List[Dict]` | Main list query with filters |
| `get_remaining_inventory()` | `(purchase_id: int, session: Optional[Session]) -> Decimal` | FIFO remaining calculation |
| `can_edit_purchase()` | `(purchase_id: int, new_quantity: Decimal, session: Optional[Session]) -> Tuple[bool, str]` | Validate edit against consumed qty |
| `can_delete_purchase()` | `(purchase_id: int, session: Optional[Session]) -> Tuple[bool, str]` | Check if any depletions exist |
| `update_purchase()` | `(purchase_id: int, updates: Dict, session: Optional[Session]) -> Purchase` | Apply edits, recalculate FIFO costs |
| `get_purchase_usage_history()` | `(purchase_id: int, session: Optional[Session]) -> List[Dict]` | Depletions with recipe info |

### Phase 2: Tab UI (Claude)

Create `PurchasesTab` following `InventoryTab` pattern:
- Header with title/subtitle
- Controls row: [Add Purchase] button + date range dropdown + supplier dropdown + search box
- ttk.Treeview with columns: Date, Product, Supplier, Qty, Unit Price, Total, Remaining
- Context menu: Edit, Delete, View Details
- Grid expansion: 70-80% vertical space for list

### Phase 3: Add Purchase Dialog (Claude)

Create `AddPurchaseDialog` following `AdjustmentDialog` pattern:
- Product dropdown with type-ahead (ComboBox)
- Date picker (defaults to today)
- Quantity entry (1 decimal place)
- Unit price entry (auto-fills from last purchase)
- Supplier dropdown (defaults to preferred_supplier)
- Notes text area (optional)
- Live preview: Total cost, inventory impact
- Validation: date not future, qty > 0, price >= 0

### Phase 4: Edit Purchase Dialog (Gemini)

Create `EditPurchaseDialog`:
- Pre-filled from existing purchase
- Product field read-only
- Editable: date, quantity, price, supplier, notes
- Validation: new_quantity >= consumed_quantity
- Preview: cost changes, FIFO recalculation impact

### Phase 5: View Details Dialog (Gemini)

Create `PurchaseDetailsDialog`:
- Purchase info section: date, supplier, price, notes
- Inventory tracking: original, used, remaining quantities
- Usage history table: date, recipe, quantity, cost per depletion
- Quick action: [Edit Purchase] button

### Phase 6: Integration & Testing (Claude)

- Wire PurchasesTab into PurchaseDashboard
- Unit tests for all service methods
- Integration tests for CRUD workflows
- Manual testing with real data

## Complexity Tracking

*No Constitution violations requiring justification.*

| Decision | Rationale |
|----------|-----------|
| Extend PurchaseService vs. new service | Keeps related logic together; follows existing pattern |
| Three separate dialogs vs. unified form | Matches existing patterns (AdjustmentDialog); clearer separation of concerns |
| ttk.Treeview vs. CTkScrollableFrame | Performance (handles 500+ rows); matches InventoryTab |

## Key Implementation Notes

### Session Management
All new service methods MUST follow the session pattern:
```python
def method_name(..., session: Optional[Session] = None) -> ReturnType:
    def _impl(sess: Session) -> ReturnType:
        # implementation using sess

    if session is not None:
        return _impl(session)
    with session_scope() as sess:
        return _impl(sess)
```

### Quantity Precision
Per clarification, quantity allows 1 decimal place for loose/bulk goods:
- Input validation: `Decimal` with 1 decimal place
- Display: format as "1.5 packages" not "1.50"

### Default Filter
Date range defaults to "Last 30 days" per clarification.

### Delete Cascade
Deleting a purchase cascades to linked InventoryItem records via foreign key.

## Next Steps

After `/spec-kitty.tasks` generates work packages:
1. Claude implements service layer (blocking)
2. Claude starts Tab UI + Add dialog
3. Gemini starts Edit + View Details dialogs (parallel)
4. Integration and testing
