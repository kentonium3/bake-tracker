# Implementation Plan: Recipe Decomposition & Aggregation

**Branch**: `072-recipe-decomposition-aggregation` | **Date**: 2026-01-27 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `kitty-specs/072-recipe-decomposition-aggregation/spec.md`

## Summary

Implement `calculate_recipe_requirements(event_id)` service method that recursively decomposes event FG selections into aggregated recipe requirements. The function traverses bundle hierarchies, multiplies quantities at each nesting level, and sums by recipe to produce a dictionary mapping Recipe objects to total quantities needed.

## Technical Context

**Language/Version**: Python 3.10+
**Primary Dependencies**: SQLAlchemy 2.x
**Storage**: SQLite (read-only for this feature)
**Testing**: pytest
**Target Platform**: Desktop (CustomTkinter app)
**Project Type**: Single project
**Performance Goals**: <100ms for events with up to 50 FG selections
**Constraints**: Max 5 levels of bundle nesting (existing MAX_FG_NESTING_DEPTH)
**Scale/Scope**: Single-user desktop application

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-checked after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. User-Centric Design | PASS | Infrastructure for planning features |
| II. Data Integrity | PASS | Read-only, no mutations |
| III. Future-Proof Schema | PASS | Uses existing schema |
| IV. Test-Driven Development | PASS | Tests defined in spec |
| V. Layered Architecture | PASS | Service layer only |
| VI. Schema Change Strategy | N/A | No schema changes |
| VII. Pragmatic Aspiration | PASS | Foundation for batch calculation (F073) |

## Project Structure

### Documentation (this feature)

```
kitty-specs/072-recipe-decomposition-aggregation/
├── spec.md              # Feature specification
├── plan.md              # This file
├── research.md          # Pattern research
├── checklists/          # Quality checklists
│   └── requirements.md
└── tasks/               # Work packages (generated by /spec-kitty.tasks)
```

### Source Code (repository root)

```
src/
├── services/
│   ├── planning_service.py    # NEW: calculate_recipe_requirements()
│   └── event_service.py       # Reference: get_required_recipes() pattern
├── models/
│   ├── event_finished_good.py # Input: event FG selections
│   ├── finished_good.py       # Bundle model
│   ├── composition.py         # Component junction
│   ├── finished_unit.py       # Atomic item with recipe_id
│   └── recipe.py              # Output: Recipe objects
└── tests/
    └── test_planning_service.py  # NEW: F072 tests
```

**Structure Decision**: Single project structure. New service file `planning_service.py` for planning-related business logic. Follows existing pattern from `planning_snapshot_service.py`.

## Technical Design

### Public API

```python
def calculate_recipe_requirements(
    event_id: int,
    session: Session = None,
) -> Dict[Recipe, int]:
    """
    Calculate aggregated recipe requirements for an event.

    Args:
        event_id: The Event to calculate requirements for
        session: Optional session for transaction sharing

    Returns:
        Dictionary mapping Recipe objects to total quantities needed

    Raises:
        ValidationError: If event not found or FG has no recipe
        CircularReferenceError: If bundle contains circular reference
        MaxDepthExceededError: If nesting exceeds limit
    """
```

### Internal Functions

```python
def _decompose_fg_to_recipes(
    fg_id: int,
    multiplier: int,
    session: Session,
    _path: Set[int],
    _depth: int,
) -> Dict[Recipe, int]:
    """Recursively decompose a single FinishedGood with quantity tracking."""
```

### Algorithm

1. Query `EventFinishedGood` records for `event_id`
2. Initialize empty result dict
3. For each EventFinishedGood record:
   - Call `_decompose_fg_to_recipes(fg_id, quantity, session, set(), 0)`
   - Merge results into main dict (summing quantities)
4. Return aggregated dict

### Decomposition Logic

```
_decompose_fg_to_recipes(fg_id, multiplier, session, _path, _depth):
    1. Check depth limit
    2. Check cycle (fg_id in _path)
    3. Add fg_id to _path
    4. Query FinishedGood with components
    5. For each Composition:
       - effective_qty = component_quantity * multiplier
       - If finished_unit_id:
           - Get recipe from finished_unit_component.recipe
           - Add to result dict (sum if exists)
       - If finished_good_id:
           - Recurse with effective_qty
           - Merge child results into result dict
    6. Remove fg_id from _path
    7. Return result dict
```

### Edge Case Handling

| Edge Case | Handling |
|-----------|----------|
| Empty event (no FG selections) | Return empty dict `{}` |
| FG with no components | Skip, return empty for that FG |
| FinishedUnit without recipe | Raise `ValidationError` |
| Circular reference | Raise `CircularReferenceError` |
| Zero-quantity component | Skip component |
| DAG (same FG multiple places) | Allowed - path-based detection only |
| Event not found | Raise `ValidationError` |

## Dependencies

### Reused from Codebase

- `MAX_FG_NESTING_DEPTH` constant from `event_service.py`
- `CircularReferenceError`, `MaxDepthExceededError` from `event_service.py`
- `ValidationError` from existing validation module
- `session_scope()` from `database.py`

### Models Used (Read-Only)

- `Event` - validate event exists
- `EventFinishedGood` - get FG selections with quantities
- `FinishedGood` - bundle traversal
- `Composition` - component relationships
- `FinishedUnit` - atomic items
- `Recipe` - output mapping

## Testing Strategy

### Unit Tests

1. **Single atomic FG** - Returns single recipe with correct quantity
2. **Single bundle** - Decomposes to component recipes with multiplied quantities
3. **Nested bundles** - Correctly multiplies through multiple levels
4. **Recipe aggregation** - Multiple FGs sharing same recipe sum correctly
5. **Empty event** - Returns empty dict
6. **Circular reference** - Raises CircularReferenceError
7. **Missing recipe** - Raises ValidationError
8. **DAG pattern** - Same FG in multiple branches works correctly

### Test Data Requirements

- Event with single atomic FG
- Event with bundle containing 2+ FinishedUnits
- Event with 2-level nested bundle
- Event with 3+ FGs sharing same recipe
- Bundle with circular reference (for error test)
- FinishedUnit without recipe (for error test)

## Work Package Outline

| WP | Focus | Deliverables |
|----|-------|--------------|
| WP01 | Core decomposition | `_decompose_fg_to_recipes()` with cycle detection |
| WP02 | Public API | `calculate_recipe_requirements()` with event query |
| WP03 | Edge cases & validation | Error handling, empty event, missing recipe |

## Complexity Tracking

*No constitution violations identified.*

| Aspect | Complexity | Justification |
|--------|------------|---------------|
| New service file | Low | Follows existing pattern, single responsibility |
| Recursive algorithm | Medium | Reuses proven F070 pattern |
| Exception imports | Low | Reuse existing exception classes |

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Performance with deep nesting | Low | Low | MAX_DEPTH limit exists |
| Cycle in production data | Very Low | Medium | Detection raises clear error |
| Session management issues | Low | Medium | Follow CLAUDE.md session patterns |

## Success Metrics

- [ ] All acceptance scenarios from spec pass
- [ ] Handles 5-level nesting correctly
- [ ] Completes in <100ms for 50 FG event
- [ ] 100% edge cases have tests
- [ ] No constitution violations
