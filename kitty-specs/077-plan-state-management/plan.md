# Implementation Plan: Plan State Management

**Branch**: `077-plan-state-management` | **Date**: 2026-01-27 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/kitty-specs/077-plan-state-management/spec.md`

## Summary

Implement a plan lifecycle state machine for events with four states (DRAFT → LOCKED → IN_PRODUCTION → COMPLETED). This feature activates the existing `plan_state` field and `PlanState` enum (F068) by adding:

1. **State transition service** (`plan_state_service.py`) with validated transitions
2. **Modification guards** in existing services (recipe, FG, batch decision) that check plan state before allowing changes
3. **UI integration** in the Planning Tab showing state and transition controls

## Technical Context

**Language/Version**: Python 3.10+
**Primary Dependencies**: SQLAlchemy 2.x, CustomTkinter
**Storage**: SQLite with WAL mode (existing database)
**Testing**: pytest (unit + integration tests)
**Target Platform**: Desktop (Windows/macOS)
**Project Type**: Single desktop application
**Performance Goals**: State transitions < 100ms, UI feedback immediate
**Constraints**: Must not break existing planning workflows; modifications only prevented, not undone
**Scale/Scope**: Single user, < 100 events

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. User-Centric Design | ✅ PASS | Feature solves real workflow need (prevent accidental changes during production) |
| II. Data Integrity | ✅ PASS | State machine protects plan integrity during production |
| III. Future-Proof Schema | ✅ PASS | Uses existing schema fields (plan_state from F068) |
| IV. Test-Driven Development | ✅ PASS | All service methods will have unit tests |
| V. Layered Architecture | ✅ PASS | Service layer handles state logic; UI displays state and buttons |
| VI. Schema Change Strategy | ✅ PASS | No schema changes required (field already exists) |
| VII. Pragmatic Aspiration | ✅ PASS | Web migration cost LOW (service layer already API-ready) |

**No violations - proceed to implementation.**

## Project Structure

### Documentation (this feature)

```
kitty-specs/077-plan-state-management/
├── plan.md              # This file
├── spec.md              # Feature specification
├── meta.json            # Feature metadata
├── checklists/          # Quality checklists
└── tasks/               # Work package files (generated by /spec-kitty.tasks)
```

### Source Code (repository root)

```
src/
├── models/
│   └── event.py                    # PlanState enum already defined (F068)
├── services/
│   ├── plan_state_service.py       # NEW: State transition + validation logic
│   ├── event_service.py            # MODIFY: Add state guard to set_event_recipes
│   └── batch_decision_service.py   # MODIFY: Add state guard (allow DRAFT+LOCKED)
├── ui/
│   └── planning_tab.py             # MODIFY: Add state display + transition buttons
└── tests/
    ├── test_plan_state_service.py  # NEW: Unit tests for state transitions
    └── integration/
        └── test_plan_state_integration.py  # NEW: Integration tests
```

**Structure Decision**: Single project (existing structure). New service file for state management, modifications to existing services for guards, UI updates to planning tab.

## Design Decisions

### D1: State Transition Service Pattern

**Decision**: Create dedicated `plan_state_service.py` with explicit transition functions.

**Rationale**:
- Clean separation of state logic from event CRUD
- Each transition function validates current state before proceeding
- Easy to test and reason about

**Pattern**:
```python
def lock_plan(event_id: int, session: Session = None) -> Event:
    """Transition from DRAFT to LOCKED."""
    # Validate current state is DRAFT
    # Update to LOCKED
    # Return updated event
```

### D2: Modification Guards via Decorator or Inline Check

**Decision**: Inline state check at service function entry (not decorator).

**Rationale**:
- More explicit and readable
- Different functions have different allowed states (e.g., batch decisions allow DRAFT+LOCKED)
- Easier to customize error messages per function

**Pattern**:
```python
def set_event_recipes(session, event_id, recipe_ids):
    event = session.query(Event).filter(Event.id == event_id).first()
    if event.plan_state != PlanState.DRAFT:
        raise PlanStateError(f"Cannot modify recipes: plan is {event.plan_state.value}")
    # ... existing logic
```

### D3: State Transition Error Handling

**Decision**: Create `PlanStateError` exception class in `exceptions.py`.

**Rationale**:
- Consistent error type for all state-related violations
- UI can catch specifically and display appropriate message
- Distinguishes from validation errors and database errors

### D4: UI State Display

**Decision**: Add state indicator and transition buttons as a collapsible/expandable section in planning tab.

**Rationale**:
- State is important but doesn't need to dominate the UI
- Buttons appear contextually based on current state
- Matches existing collapsible frame pattern in planning tab

## Phase Outputs

### Phase 0: Research (Minimal)

No external research needed. All patterns are established in the codebase:
- Service pattern: Follow `batch_decision_service.py` structure
- Session management: Accept `session=None`, use session_scope if None
- Exception pattern: Follow `exceptions.py` existing patterns
- UI pattern: Follow planning_tab.py frame structure

### Phase 1: Design Artifacts

**Data Model** (no changes - using existing schema):
- `Event.plan_state`: Enum column (PlanState) - already exists from F068
- Valid values: DRAFT, LOCKED, IN_PRODUCTION, COMPLETED
- Default: DRAFT

**State Transition Rules**:

| From State | To State | Function | Condition |
|------------|----------|----------|-----------|
| DRAFT | LOCKED | `lock_plan()` | Always allowed |
| LOCKED | IN_PRODUCTION | `start_production()` | Always allowed |
| IN_PRODUCTION | COMPLETED | `complete_production()` | Always allowed |
| * | * (other) | - | Raises PlanStateError |

**Modification Rules by State**:

| Operation | DRAFT | LOCKED | IN_PRODUCTION | COMPLETED |
|-----------|-------|--------|---------------|-----------|
| Add/remove recipes | ✅ | ❌ | ❌ | ❌ |
| Add/remove FGs | ✅ | ❌ | ❌ | ❌ |
| Change FG quantities | ✅ | ❌ | ❌ | ❌ |
| Modify batch decisions | ✅ | ✅ | ❌ | ❌ |
| View all data | ✅ | ✅ | ✅ | ✅ |

**UI State Controls**:

| Current State | Visible Button | Action |
|---------------|----------------|--------|
| DRAFT | "Lock Plan" | Calls `lock_plan()` |
| LOCKED | "Start Production" | Calls `start_production()` |
| IN_PRODUCTION | "Complete Production" | Calls `complete_production()` |
| COMPLETED | (none) | Read-only |

## Work Package Outline

### WP01: Plan State Service (Foundation)
- Create `plan_state_service.py` with transition functions
- Add `PlanStateError` to exceptions.py
- Unit tests for all transitions and edge cases

### WP02: Modification Guards (Service Layer)
- Add state checks to `set_event_recipes()` in event_service.py
- Add state checks to `set_event_fg_quantities()` in event_service.py
- Add state checks to batch_decision_service.py (allow DRAFT+LOCKED)
- Integration tests for guard behavior

### WP03: UI Integration (Planning Tab)
- Add state indicator display
- Add transition buttons with appropriate enable/disable logic
- Wire buttons to service calls with error handling

## Complexity Tracking

*No constitution violations - table not needed.*

## Next Steps

Run `/spec-kitty.tasks` to generate detailed work package prompts.
