# Work Packages: Finished Goods Filtering for Event Planning

**Inputs**: Design documents from `/kitty-specs/070-finished-goods-filtering/`
**Prerequisites**: plan.md (required), spec.md (user stories), research.md, data-model.md

**Tests**: Unit tests required for service layer (constitution Principle IV). UI tests for component validation.

**Organization**: Fine-grained subtasks (`Txxx`) roll up into work packages (`WPxx`). Each work package must be independently deliverable and testable.

**Prompt Files**: Each work package references a matching prompt file in `/tasks/` generated by `/spec-kitty.tasks`.

## Subtask Format: `[Txxx] [P?] Description`
- **[P]** indicates the subtask can proceed in parallel (different files/components).
- Include precise file paths or modules.

---

## Work Package WP01: Bundle Decomposition Algorithm (Priority: P1)

**Goal**: Implement recursive algorithm to decompose FinishedGood bundles into required recipe IDs.
**Independent Test**: Unit tests pass for atomic FGs, bundles, nested bundles, circular references, and deep nesting.
**Prompt**: `/tasks/WP01-bundle-decomposition.md`
**Agent**: Claude (lead)
**Estimated Size**: ~350 lines

### Included Subtasks
- [x] T001 Create exception classes (CircularReferenceError, MaxDepthExceededError) in `src/services/event_service.py`
- [x] T002 Implement `get_required_recipes(fg_id, session)` recursive function
- [x] T003 Add circular reference detection using visited set
- [x] T004 Add depth limiting (max 10 levels)
- [x] T005 Write unit tests for decomposition in `src/tests/test_fg_availability.py`

### Implementation Notes
- Follow pattern from `batch_calculation.explode_bundle_requirements()` (lines 149-234)
- Traverse `FinishedGood.components` → check `finished_unit_component.recipe_id` or recurse on `finished_good_component`
- Return `Set[int]` of unique recipe IDs
- Session parameter is required (no internal session creation)

### Parallel Opportunities
- None - this is foundational for all other WPs

### Dependencies
- None (starting package)

### Risks & Mitigations
- Circular references → Detect with `_visited` set before recursing
- Deep nesting → Limit to 10 levels; raise `MaxDepthExceededError`

---

## Work Package WP02: Availability Checking + Cascade Removal (Priority: P1)

**Goal**: Implement FG availability checking and automatic removal of invalid FG selections when recipes are deselected.
**Independent Test**: Unit tests pass for availability checking, filtering, and cascade removal.
**Prompt**: `/tasks/WP02-availability-cascade.md`
**Agent**: Claude (lead)
**Estimated Size**: ~450 lines

### Included Subtasks
- [x] T006 Create `AvailabilityResult` and `RemovedFGInfo` dataclasses in `src/services/event_service.py`
- [x] T007 Implement `check_fg_availability(fg_id, selected_recipe_ids, session)` function
- [ ] T008 Implement `get_available_finished_goods(event_id, session)` function
- [ ] T009 Implement `remove_invalid_fg_selections(event_id, session)` function
- [ ] T010 Modify `set_event_recipes()` to call `remove_invalid_fg_selections()` after updating recipes
- [ ] T011 Write unit tests for availability checking in `src/tests/test_fg_availability.py`
- [ ] T012 Write unit tests for cascade removal in `src/tests/test_fg_availability.py`

### Implementation Notes
- `check_fg_availability()` uses `get_required_recipes()` from WP01
- `get_available_finished_goods()` queries all FGs, filters by availability
- `remove_invalid_fg_selections()` checks each selected FG, removes if no longer available
- Return `List[RemovedFGInfo]` for UI notification

### Parallel Opportunities
- T011 and T012 can be written in parallel

### Dependencies
- Depends on WP01 (`get_required_recipes()` function)

### Risks & Mitigations
- Session detachment → All methods accept `session` parameter (follow F069 pattern)
- Performance → Memoize `get_required_recipes()` if profiling shows issues (defer optimization)

---

## Work Package WP03: FG Selection Frame UI Component (Priority: P2)

**Goal**: Create `FGSelectionFrame` widget for selecting finished goods from available list.
**Independent Test**: UI tests pass for rendering, selection, and callback handling.
**Prompt**: `/tasks/WP03-fg-selection-frame.md`
**Agent**: Gemini
**Estimated Size**: ~400 lines

### Included Subtasks
- [ ] T013 [P] Create `FGSelectionFrame(CTkFrame)` class structure in `src/ui/components/fg_selection_frame.py`
- [ ] T014 Implement `populate_finished_goods(fgs: List[FinishedGood], event_name: str)` method
- [ ] T015 Implement checkbox rendering per FG with display name
- [ ] T016 Implement live count display ("X of Y selected")
- [ ] T017 Implement Save/Cancel buttons with callback support
- [ ] T018 [P] Write UI tests in `src/tests/test_fg_selection_frame.py`

### Implementation Notes
- Follow pattern from `src/ui/components/recipe_selection_frame.py`
- Use CTkScrollableFrame for FG list
- Checkboxes bound to IntVar for selection tracking
- Callbacks: `on_save(selected_fg_ids: List[int])`, `on_cancel()`

### Parallel Opportunities
- T013 (structure) and T018 (tests) can start in parallel
- T14-T17 are sequential (build on class structure)

### Dependencies
- Depends on WP01 and WP02 (service methods for filtering)

### Risks & Mitigations
- Large FG catalogs → Use scrollable frame with lazy loading if needed (defer optimization)

---

## Work Package WP04: Planning Tab Integration + Notifications (Priority: P2)

**Goal**: Embed FGSelectionFrame in Planning Tab, wire recipe selection to FG list refresh, show notifications on auto-removal.
**Independent Test**: Integration tests pass for FG selection workflow and notification display.
**Prompt**: `/tasks/WP04-planning-tab-integration.md`
**Agent**: Codex
**Estimated Size**: ~500 lines

### Included Subtasks
- [ ] T019 Add imports and instance variables for FG selection in `src/ui/planning_tab.py`
- [ ] T020 Create `_create_fg_selection_frame()` method
- [ ] T021 Embed FGSelectionFrame in grid layout (row 3, below recipe selection)
- [ ] T022 Wire recipe selection save to trigger FG list refresh
- [ ] T023 Implement `_on_fg_selection_save(selected_fg_ids)` callback
- [ ] T024 Implement `_on_fg_selection_cancel()` callback
- [ ] T025 Show notification when FGs auto-removed (from cascade removal)
- [ ] T026 Write integration tests in `src/tests/test_planning_tab_fg.py`

### Implementation Notes
- Follow pattern from F069 recipe selection integration
- Grid layout: row 2 = recipe selection, row 3 = FG selection, row 4 = status bar
- Recipe save callback should check for removed FGs and show notification
- Use `_update_status()` for notification display

### Parallel Opportunities
- T019-T021 (setup) can be done first, then T22-T25 (wiring)
- T026 can be written alongside implementation

### Dependencies
- Depends on WP01 and WP02 (service methods)
- Depends on WP03 (FGSelectionFrame component) for embedding

### Risks & Mitigations
- Race conditions on rapid recipe toggles → Service layer is stateless; debounce in UI if needed
- Grid layout conflicts → Adjust row indices carefully (F069 uses rows 0-2)

---

## Dependency & Execution Summary

- **Phase 1 (Sequential)**: WP01 → WP02 (Claude lead, establishes service layer)
- **Phase 2 (Parallel)**: WP03 || WP04 (Gemini + Codex, after Phase 1 complete)

```
WP01 (Bundle Decomposition)
  │
  └─→ WP02 (Availability + Cascade)
        │
        ├─→ WP03 (FG Selection Frame UI) [Gemini]
        │
        └─→ WP04 (Planning Tab Integration) [Codex]
                  │
                  └─→ Depends on WP03 for embedding
```

**Note**: WP04 depends on both WP02 (service) AND WP03 (UI component). Start WP03 first to unblock WP04 sooner.

**MVP Scope**: WP01 + WP02 + WP03 + WP04 (all required for complete feature)

---

## Subtask Index (Reference)

| Subtask ID | Summary | Work Package | Priority | Parallel? |
|------------|---------|--------------|----------|-----------|
| T001 | Create exception classes | WP01 | P1 | No |
| T002 | Implement get_required_recipes() | WP01 | P1 | No |
| T003 | Add circular reference detection | WP01 | P1 | No |
| T004 | Add depth limiting | WP01 | P1 | No |
| T005 | Write decomposition tests | WP01 | P1 | No |
| T006 | Create DTO dataclasses | WP02 | P1 | No |
| T007 | Implement check_fg_availability() | WP02 | P1 | No |
| T008 | Implement get_available_finished_goods() | WP02 | P1 | No |
| T009 | Implement remove_invalid_fg_selections() | WP02 | P1 | No |
| T010 | Modify set_event_recipes() for cascade | WP02 | P1 | No |
| T011 | Write availability tests | WP02 | P1 | Yes |
| T012 | Write cascade removal tests | WP02 | P1 | Yes |
| T013 | Create FGSelectionFrame class | WP03 | P2 | Yes |
| T014 | Implement populate_finished_goods() | WP03 | P2 | No |
| T015 | Implement checkbox rendering | WP03 | P2 | No |
| T016 | Implement live count display | WP03 | P2 | No |
| T017 | Implement Save/Cancel buttons | WP03 | P2 | No |
| T018 | Write FGSelectionFrame tests | WP03 | P2 | Yes |
| T019 | Add imports and instance vars | WP04 | P2 | No |
| T020 | Create _create_fg_selection_frame() | WP04 | P2 | No |
| T021 | Embed in grid layout | WP04 | P2 | No |
| T022 | Wire recipe save to FG refresh | WP04 | P2 | No |
| T023 | Implement _on_fg_selection_save() | WP04 | P2 | No |
| T024 | Implement _on_fg_selection_cancel() | WP04 | P2 | No |
| T025 | Show auto-removal notification | WP04 | P2 | No |
| T026 | Write integration tests | WP04 | P2 | Yes |
