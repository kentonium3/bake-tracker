# Implementation Plan: Auto-Generation of Finished Goods from Finished Units

**Branch**: `098-auto-generation-finished-goods` | **Date**: 2026-02-08 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `kitty-specs/098-auto-generation-finished-goods/spec.md`

## Summary

Automatically create a bare FinishedGood (with `assembly_type=BARE` and a single `Composition` link) whenever a FinishedUnit is created from an EA-yield recipe. Keep the bare FG in sync on name/category updates and cascade-delete it (with assembly-reference protection) when the FU is deleted. This requires first refactoring the recipe save workflow to move FinishedUnit orchestration from the UI layer into the service layer, establishing a single atomic transaction for the entire recipe save.

## Technical Context

**Language/Version**: Python 3.10+
**Primary Dependencies**: SQLAlchemy 2.x, CustomTkinter
**Storage**: SQLite with WAL mode
**Testing**: pytest
**Target Platform**: macOS/Windows desktop (single-user)
**Project Type**: Single desktop application
**Performance Goals**: N/A (single-user, local operations)
**Constraints**: All recipe save operations must be atomic (single transaction)
**Scale/Scope**: Single user, ~100 recipes, ~50 FinishedUnits

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. User-Centric Design | PASS | Eliminates manual FG creation burden; validated by user testing 2026-02-08 |
| II. Data Integrity | PASS | 1:1 relationship enforced atomically; cascade deletes prevent orphans |
| III. Future-Proof Schema | PASS | No schema changes needed; uses existing AssemblyType.BARE and Composition |
| IV. Test-Driven Development | PASS | All new service functions will have unit tests; integration tests for full workflow |
| V. Layered Architecture | PASS + FIXES VIOLATION | Moves FU orchestration from UI to service layer, fixing existing architecture violation |
| VI.C. Session Parameters | PASS + FIXES VIOLATION | Adds session parameter to finished_unit_service CRUD methods |
| VII. Schema Change Strategy | PASS | No schema changes required |

**Post-Phase 1 Re-check**: No new violations introduced. Design uses existing models and patterns.

## Project Structure

### Documentation (this feature)

```
kitty-specs/098-auto-generation-finished-goods/
├── plan.md              # This file
├── research.md          # Phase 0 research findings
├── data-model.md        # Phase 1 data model analysis
├── spec.md              # Feature specification
├── checklists/
│   └── requirements.md  # Spec quality checklist
└── tasks.md             # Phase 2 output (generated by /spec-kitty.tasks)
```

### Source Code (files modified by this feature)

```
src/
├── services/
│   ├── recipe_service.py              # New: save_recipe_with_yields() orchestration
│   ├── finished_unit_service.py       # Modified: add session parameter to CRUD
│   ├── finished_good_service.py       # New: auto_create_bare_fg(), sync_bare_fg(), find_bare_fg_for_unit()
│   └── catalog_import_service.py      # Modified: call auto-generation during bulk import
├── ui/
│   └── recipes_tab.py                 # Modified: replace _save_yield_types() with service call
└── tests/
    ├── test_recipe_service.py         # New/expanded: orchestration tests
    ├── test_finished_unit_service.py   # Expanded: session parameter tests
    ├── test_finished_good_service.py   # Expanded: auto-generation tests
    └── test_auto_generation_integration.py  # New: end-to-end workflow tests
```

**Structure Decision**: Existing single-project structure. No new modules or packages — all changes fit within existing service files.

## Complexity Tracking

*No constitution violations to justify. This feature fixes two existing violations.*

| Existing Violation Fixed | How |
|--------------------------|-----|
| UI-layer business logic in `recipes_tab._save_yield_types()` | Move to `recipe_service.save_recipe_with_yields()` |
| Missing session parameter on `finished_unit_service` CRUD | Add `session: Optional[Session] = None` to all three methods |

## Parallel Work Analysis

### Dependency Graph

```
WP01: Add session param to finished_unit_service (foundation)
  ↓
WP02: Create recipe save orchestration in recipe_service (depends on WP01)
  ↓
WP03: Auto-create bare FG on FU creation (depends on WP02)
  ↓
WP04: Propagate FU updates to bare FG (depends on WP03)
  ↓
WP05: Cascade delete with assembly protection (depends on WP03)
  ↓  ↓
WP06: Refactor UI to use new orchestration (depends on WP02)
  ↓
WP07: Migration of existing bare FGs (depends on WP03)
  ↓
WP08: Bulk import auto-generation (depends on WP03)
```

### Work Distribution

- **Sequential (must be in order)**: WP01 → WP02 → WP03
- **Parallel after WP03**: WP04, WP05, WP06, WP07, WP08 can all proceed independently
- **Agent assignments**: WP04+WP05 (propagation+delete) can go to Gemini while lead works on WP06 (UI refactor)

### Coordination Points

- **After WP02**: Verify recipe save orchestration works with existing tests before adding auto-generation
- **After WP06**: Full integration test — UI calls service, service creates Recipe + FU + bare FG atomically
- **After all WPs**: Run full test suite to verify no regressions

## Design Decisions

### D1: No schema changes

The existing `AssemblyType.BARE` enum value and `Composition` model provide everything needed. No new columns, tables, or migrations.

### D2: Orchestration lives in recipe_service

`recipe_service.save_recipe_with_yields()` becomes the single entry point for recipe saves. It coordinates:
1. Recipe create/update
2. FinishedUnit reconciliation (create/update/delete)
3. Bare FinishedGood auto-generation/sync/cascade-delete

This follows the established pattern where `finished_good_service.create_finished_good()` already orchestrates FG + Composition creation atomically.

### D3: Bare FG lookup via Composition join

To find the bare FG for a given FU, query `Composition WHERE finished_unit_id = :fu_id JOIN FinishedGood WHERE assembly_type = 'bare'`. This is the canonical path — no need for a direct FK between FU and FG.

### D4: Assembly protection before cascade delete

Before deleting a bare FG, check `Composition WHERE finished_good_id = :bare_fg_id`. If any records exist, the bare FG is used as a component in an assembled FG and deletion must be blocked with an error listing the affected assemblies.

### D5: Reconciliation pattern for yield types

The existing `_save_yield_types()` reconciliation pattern (compare new list to existing, create/update/delete) is the correct approach. It moves into the service layer as-is, with the addition of FG auto-generation hooks at each step:
- FU created → bare FG created
- FU updated → bare FG synced
- FU deleted → bare FG cascade-deleted (with protection check)

### D6: Import integration

`catalog_import_service._import_recipes_impl()` already operates within a single session. After creating a recipe and its yield types, call the auto-generation function within the same session to create bare FGs.
