# Work Packages: Auto-Generation of Finished Goods from Finished Units

**Inputs**: Design documents from `kitty-specs/098-auto-generation-finished-goods/`
**Prerequisites**: plan.md (required), spec.md (user stories), research.md, data-model.md

**Tests**: Included in each WP. Constitution Principle IV (TDD) requires service layer tests.

**Organization**: Fine-grained subtasks (`Txxx`) roll up into work packages (`WPxx`). Each work package is independently deliverable and testable.

**Prompt Files**: Each work package references a matching prompt file in `tasks/` generated by `/spec-kitty.tasks`.

## Subtask Format: `[Txxx] [P?] Description`
- **[P]** indicates the subtask can proceed in parallel (different files/components).
- Precise file paths included.

---

## Work Package WP01: Add Session Parameter to finished_unit_service (Priority: P0)

**Goal**: Add `session: Optional[Session] = None` parameter to all CRUD methods in `finished_unit_service.py`, enabling transaction composition with callers. Fixes Constitution Principle VI.C violation.
**Independent Test**: All existing finished_unit_service tests pass unchanged (backward compat). New tests verify session parameter is respected when provided.
**Prompt**: `tasks/WP01-fu-service-session-param.md`
**Estimated Size**: ~350 lines

### Included Subtasks
- [ ] T001 Refactor `create_finished_unit()` to accept and use `session` parameter
- [ ] T002 Refactor `update_finished_unit()` to accept and use `session` parameter
- [ ] T003 Refactor `delete_finished_unit()` to accept and use `session` parameter
- [ ] T004 Update module-level convenience functions to pass through `session`
- [ ] T005 Write tests: session parameter is used when provided (no new session_scope)
- [ ] T006 Verify all existing tests pass with `session=None` (backward compatibility)

### Implementation Notes
- Follow the `_impl` pattern already used in `finished_good_service.py`
- Each method gets: `if session is not None: return _impl(session)` / `else: with session_scope() as sess: return _impl(sess)`
- Module-level wrappers must forward `session` kwarg to class methods

### Parallel Opportunities
- T001, T002, T003 can be done in parallel (different methods, same file)

### Dependencies
- None (starting package)

### Risks & Mitigations
- Risk: Breaking existing callers that don't pass session → Mitigated by `session=None` default (backward compatible)
- Risk: Static method pattern may complicate session injection → Follow exact pattern from `finished_good_service.py`

---

## Work Package WP02: Recipe Save Orchestration (Priority: P0)

**Goal**: Create `save_recipe_with_yields()` in `recipe_service.py` that orchestrates recipe + yield type saves in a single atomic transaction. Moves business logic from UI layer to service layer, fixing Constitution Principle V violation.
**Independent Test**: Create recipe with yield types via new orchestration function; verify all records created in single transaction that rolls back atomically on failure.
**Prompt**: `tasks/WP02-recipe-save-orchestration.md`
**Estimated Size**: ~400 lines

### Included Subtasks
- [ ] T007 Design and implement `save_recipe_with_yields()` function signature
- [ ] T008 Implement yield type reconciliation logic (port from `_save_yield_types()`)
- [ ] T009 Wire FU create/update/delete calls within single session
- [ ] T010 Write tests: create recipe with multiple yield types atomically
- [ ] T011 Write tests: yield reconciliation (add new, update existing, remove old)
- [ ] T012 Write tests: transaction rollback on any failure

### Implementation Notes
- Port reconciliation logic from `recipes_tab._save_yield_types()` (lines 660-718)
- Use session parameter from WP01 to pass session to FU service calls
- Function accepts recipe data dict + yield_types list, returns Recipe
- Must handle both create and update flows (new recipe vs existing recipe)

### Parallel Opportunities
- None within this WP (sequential logic)

### Dependencies
- Depends on WP01 (session parameter on FU service)

### Risks & Mitigations
- Risk: Subtle behavior differences vs original UI code → Port logic carefully, test same scenarios
- Risk: Transaction boundary spans many operations → Ensure session.flush() at right points for FK resolution

---

## Work Package WP03: Auto-Create Bare FinishedGood on FU Creation (Priority: P1) MVP

**Goal**: When a FinishedUnit is created, automatically create a corresponding bare FinishedGood (`assembly_type=BARE`) with a single Composition link. This is the core feature delivering User Story 1.
**Independent Test**: Create a recipe with EA yield → verify FU created → verify bare FG exists with single Composition linking to FU, all within same transaction.
**Prompt**: `tasks/WP03-auto-create-bare-fg.md`
**Estimated Size**: ~400 lines

### Included Subtasks
- [ ] T013 Create `find_bare_fg_for_unit()` lookup in `finished_good_service.py`
- [ ] T014 Create `auto_create_bare_finished_good()` in `finished_good_service.py`
- [ ] T015 Integrate auto-creation into `save_recipe_with_yields()` orchestration
- [ ] T016 Handle duplicate prevention (skip if bare FG already exists for this FU)
- [ ] T017 Write tests: FU created → bare FG + Composition created correctly
- [ ] T018 Write tests: duplicate prevention, edge cases, weight-yield skipping

### Implementation Notes
- `auto_create_bare_finished_good(finished_unit_id, session)` creates FG + Composition atomically
- Uses `create_finished_good(assembly_type=AssemblyType.BARE, components=[...], session=session)`
- Inherits `display_name` and `category` from FU
- Only for yield_type="EA" (skip weight-based yields)
- Composition uses `Composition.create_unit_composition(assembly_id, finished_unit_id, quantity=1)`

### Parallel Opportunities
- T013 (lookup) and T014 (creation) can be developed in parallel

### Dependencies
- Depends on WP02 (orchestration function to hook into)

### Risks & Mitigations
- Risk: Slug collision between auto-generated FG and existing manual FGs → Use same slug generation with retry logic
- Risk: Name uniqueness violation → Check existing before creation, disambiguate if needed

---

## Work Package WP04: Propagate FU Updates to Bare FG (Priority: P1)

**Goal**: When a FinishedUnit's name or category changes, automatically propagate the change to its corresponding bare FinishedGood within the same transaction. Delivers User Story 2.
**Independent Test**: Update a recipe name → verify FU name changes → verify bare FG name also changes within same transaction.
**Prompt**: `tasks/WP04-propagate-fu-updates.md`
**Estimated Size**: ~350 lines

### Included Subtasks
- [ ] T019 Create `sync_bare_finished_good()` in `finished_good_service.py`
- [ ] T020 Integrate sync into `save_recipe_with_yields()` update path
- [ ] T021 [P] Implement name propagation (display_name + slug regeneration)
- [ ] T022 [P] Implement category propagation
- [ ] T023 Write tests: name and category propagation within same transaction
- [ ] T024 Write tests: edge cases (no bare FG, only changed fields updated, unrelated FU unaffected)

### Implementation Notes
- `sync_bare_finished_good(finished_unit_id, session)` finds bare FG via Composition join, updates name/category
- Slug must be regenerated when name changes (use existing slug generation utilities)
- Only propagate if values actually changed (avoid unnecessary updates)
- Only targets `assembly_type=BARE` FGs (never touch assembled FGs)

### Parallel Opportunities
- T021 (name propagation) and T022 (category propagation) can proceed in parallel

### Dependencies
- Depends on WP03 (uses `find_bare_fg_for_unit()`)

### Risks & Mitigations
- Risk: Slug collision on rename → Use same retry logic as creation
- Risk: Propagation overwrites user customizations on bare FGs → By design, bare FGs are auto-managed; user edits go via recipe

---

## Work Package WP05: Cascade Delete with Assembly Protection (Priority: P1)

**Goal**: When a FinishedUnit is deleted, cascade-delete its bare FinishedGood and Composition record — but block deletion if the bare FG is used as a component in any assembled FinishedGood. Delivers User Story 3.
**Independent Test**: Delete recipe with no assembly refs → all records cleaned up. Delete recipe used in assembly → deletion blocked with clear error listing affected assemblies.
**Prompt**: `tasks/WP05-cascade-delete-protection.md`
**Estimated Size**: ~350 lines

### Included Subtasks
- [ ] T025 Create assembly reference check function in `finished_good_service.py`
- [ ] T026 Create `cascade_delete_bare_fg()` function
- [ ] T027 Integrate cascade delete into `save_recipe_with_yields()` delete path
- [ ] T028 Implement error message with affected assembly listing
- [ ] T029 Write tests: clean cascade delete when no assembly references
- [ ] T030 Write tests: deletion blocked with correct error when referenced by assemblies

### Implementation Notes
- Assembly check: `Composition WHERE finished_good_id = :bare_fg_id` (bare FG used as component)
- If referenced: raise descriptive error listing assembly display_names
- Cascade order: check refs → delete Composition (FG→FU link) → delete FG → allow FU deletion to proceed
- All within single session/transaction

### Parallel Opportunities
- T025 (check function) and T026 (delete function) can be developed in parallel

### Dependencies
- Depends on WP03 (uses `find_bare_fg_for_unit()`)

### Risks & Mitigations
- Risk: Missing assembly references in check → Query must check `Composition.finished_good_id` (not `finished_unit_id`)
- Risk: Confusing error message → Include assembly names, not just IDs

---

## Work Package WP06: Refactor UI to Use New Orchestration (Priority: P1)

**Goal**: Replace `recipes_tab.py._save_yield_types()` with a call to the new `recipe_service.save_recipe_with_yields()`, completing the architecture fix. UI passes data; service handles all business logic.
**Independent Test**: Full integration: user creates/edits/deletes recipe via UI → all FUs and bare FGs managed correctly via service layer.
**Prompt**: `tasks/WP06-refactor-ui-orchestration.md`
**Estimated Size**: ~300 lines

### Included Subtasks
- [ ] T031 Refactor `_add_recipe()` to call `save_recipe_with_yields()`
- [ ] T032 Refactor `_edit_recipe()` to call `save_recipe_with_yields()`
- [ ] T033 Remove `_save_yield_types()` method from `recipes_tab.py`
- [ ] T034 Update error handling in UI for new service exceptions
- [ ] T035 Write integration tests: full UI→Service→DB flow

### Implementation Notes
- `_add_recipe()` currently calls `recipe_service.create_recipe()` then `_save_yield_types()` separately
- New flow: `_add_recipe()` calls `save_recipe_with_yields(recipe_data, yield_types)` once
- Same for `_edit_recipe()` with `update_recipe_with_yields()`
- Error handling: catch `ServiceError` subclasses, display user-friendly messages
- Remove import of `finished_unit_service` from `recipes_tab.py`

### Parallel Opportunities
- T031 and T032 address different methods but same file — sequential recommended

### Dependencies
- Depends on WP02 (orchestration function must exist)
- Can proceed in parallel with WP03-WP05 (UI refactor doesn't depend on auto-generation)

### Risks & Mitigations
- Risk: Subtle behavior change visible to user → Carefully match existing dialog flow and error messages
- Risk: Recipe dialog returns data in different format than service expects → Map dialog result to service params

---

## Work Package WP07: Migration of Existing Bare FinishedGoods (Priority: P2)

**Goal**: Identify and convert existing manually-created bare FinishedGoods to auto-managed status, establishing 1:1 FU linkage retroactively. Delivers User Story 4.
**Independent Test**: Run migration on database with known manually-created bare FGs → all correctly identified, linked, and reclassified.
**Prompt**: `tasks/WP07-migrate-existing-bare-fgs.md`
**Estimated Size**: ~350 lines

### Included Subtasks
- [ ] T036 Create migration function to identify bare FGs needing conversion
- [ ] T037 Implement reclassification logic (BUNDLE → BARE for single-FU-component FGs)
- [ ] T038 Verify/establish 1:1 FU↔FG linkage for existing data
- [ ] T039 Preserve user metadata during migration (notes, custom attributes)
- [ ] T040 Write tests: migration correctly identifies and converts bare FGs
- [ ] T041 Write tests: edge cases (no matching FU, already correct, metadata preserved)

### Implementation Notes
- Identification: FG with single Composition where component is a FU, quantity=1
- These may have `assembly_type=BUNDLE` if created via builder → reclassify to `BARE`
- Preserve `notes`, `description` fields (user may have added custom content)
- Flag FGs with no matching FU for manual review (log warning, don't auto-fix)
- Migration runs as a service function callable from import/export or startup

### Parallel Opportunities
- Can run entirely in parallel with WP04, WP05, WP06, WP08

### Dependencies
- Depends on WP03 (auto-creation functions used for validation)

### Risks & Mitigations
- Risk: Misidentifying assembled FGs as bare → Strict criteria: exactly 1 Composition, type=FU, qty=1
- Risk: Data loss during migration → Preserve all existing fields, only change assembly_type

---

## Work Package WP08: Bulk Import Auto-Generation (Priority: P3)

**Goal**: Extend bulk recipe import to auto-generate FU + bare FG pairs for each EA-yield recipe, maintaining transactional integrity. Delivers User Story 5.
**Independent Test**: Import file with many EA-yield recipes → verify all FU + bare FG pairs created without duplicates; single failure rolls back entire import.
**Prompt**: `tasks/WP08-bulk-import-auto-generation.md`
**Estimated Size**: ~300 lines

### Included Subtasks
- [ ] T042 Extend `catalog_import_service._import_recipes_impl()` to create FUs during import
- [ ] T043 Add auto-generation of bare FGs within import transaction
- [ ] T044 Handle duplicate names during bulk creation (disambiguate)
- [ ] T045 Write tests: bulk import creates FU + bare FG for each EA-yield recipe
- [ ] T046 Write tests: rollback on failure, duplicate name handling

### Implementation Notes
- Import already operates within single session — add FU/FG creation to same flow
- After creating Recipe + RecipeIngredients, create FU + bare FG using WP03 functions
- Pass session from import to auto-generation functions
- Duplicate names: use existing slug generation with retry logic

### Parallel Opportunities
- Can run entirely in parallel with WP04, WP05, WP06, WP07

### Dependencies
- Depends on WP03 (auto-creation functions)

### Risks & Mitigations
- Risk: Performance with 100+ recipes → Batch operations within single session commit
- Risk: Partial import state on failure → Already handled by session transaction boundary

---

## Dependency & Execution Summary

```
WP01 (session param) ──→ WP02 (orchestration) ──→ WP03 (auto-create) ──→ WP04 (propagate)
                                    │                       │              ──→ WP05 (delete)
                                    │                       │              ──→ WP07 (migration)
                                    │                       │              ──→ WP08 (bulk import)
                                    └──→ WP06 (UI refactor)
```

- **Sequential**: WP01 → WP02 → WP03 (must be in order)
- **Parallel Wave 1 (after WP02)**: WP06 (UI refactor)
- **Parallel Wave 2 (after WP03)**: WP04, WP05, WP07, WP08
- **MVP Scope**: WP01 + WP02 + WP03 + WP06 (core auto-generation + UI integration)

---

## Subtask Index (Reference)

| Subtask | Summary | WP | Priority | Parallel? |
|---------|---------|-----|----------|-----------|
| T001 | Refactor create_finished_unit() session param | WP01 | P0 | Yes |
| T002 | Refactor update_finished_unit() session param | WP01 | P0 | Yes |
| T003 | Refactor delete_finished_unit() session param | WP01 | P0 | Yes |
| T004 | Update module-level convenience wrappers | WP01 | P0 | No |
| T005 | Tests: session parameter respected | WP01 | P0 | No |
| T006 | Tests: backward compatibility | WP01 | P0 | No |
| T007 | Design save_recipe_with_yields() signature | WP02 | P0 | No |
| T008 | Implement yield type reconciliation | WP02 | P0 | No |
| T009 | Wire FU CRUD within single session | WP02 | P0 | No |
| T010 | Tests: atomic recipe+yield creation | WP02 | P0 | No |
| T011 | Tests: yield reconciliation scenarios | WP02 | P0 | No |
| T012 | Tests: transaction rollback on failure | WP02 | P0 | No |
| T013 | Create find_bare_fg_for_unit() lookup | WP03 | P1 | Yes |
| T014 | Create auto_create_bare_finished_good() | WP03 | P1 | Yes |
| T015 | Integrate auto-creation into orchestration | WP03 | P1 | No |
| T016 | Duplicate prevention logic | WP03 | P1 | No |
| T017 | Tests: auto-creation happy path | WP03 | P1 | No |
| T018 | Tests: duplicates, edge cases, weight-yield | WP03 | P1 | No |
| T019 | Create sync_bare_finished_good() | WP04 | P1 | No |
| T020 | Integrate sync into update path | WP04 | P1 | No |
| T021 | Name propagation with slug regeneration | WP04 | P1 | Yes |
| T022 | Category propagation | WP04 | P1 | Yes |
| T023 | Tests: propagation within transaction | WP04 | P1 | No |
| T024 | Tests: edge cases (no FG, unrelated FU) | WP04 | P1 | No |
| T025 | Assembly reference check function | WP05 | P1 | Yes |
| T026 | Create cascade_delete_bare_fg() | WP05 | P1 | Yes |
| T027 | Integrate cascade delete into delete path | WP05 | P1 | No |
| T028 | Error message with assembly listing | WP05 | P1 | No |
| T029 | Tests: clean cascade delete | WP05 | P1 | No |
| T030 | Tests: deletion blocked by assembly ref | WP05 | P1 | No |
| T031 | Refactor _add_recipe() to use orchestration | WP06 | P1 | No |
| T032 | Refactor _edit_recipe() to use orchestration | WP06 | P1 | No |
| T033 | Remove _save_yield_types() method | WP06 | P1 | No |
| T034 | Update UI error handling | WP06 | P1 | No |
| T035 | Integration tests: UI→Service→DB | WP06 | P1 | No |
| T036 | Migration: identify bare FGs needing conversion | WP07 | P2 | No |
| T037 | Migration: reclassification logic | WP07 | P2 | No |
| T038 | Migration: verify/establish 1:1 linkage | WP07 | P2 | No |
| T039 | Migration: preserve user metadata | WP07 | P2 | No |
| T040 | Tests: migration correctness | WP07 | P2 | No |
| T041 | Tests: migration edge cases | WP07 | P2 | No |
| T042 | Extend import to create FUs | WP08 | P3 | No |
| T043 | Add FG auto-generation to import | WP08 | P3 | No |
| T044 | Handle duplicate names in bulk | WP08 | P3 | No |
| T045 | Tests: bulk import with auto-generation | WP08 | P3 | No |
| T046 | Tests: rollback and duplicate handling | WP08 | P3 | No |
