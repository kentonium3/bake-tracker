# Implementation Plan: Ingredient Aggregation for Batch Decisions

**Branch**: `074-ingredient-aggregation` | **Date**: 2026-01-27 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/kitty-specs/074-ingredient-aggregation/spec.md`

## Summary

Implement ingredient aggregation service that converts batch decisions (from F073) into total ingredient quantities. The service:
1. Queries BatchDecision records for an event
2. For each decision, scales recipe ingredients by batch count
3. Aggregates same (ingredient_id, unit) pairs across recipes
4. Returns totals keyed by ingredient/unit tuple

This is a prerequisite for F075 (Shopping List) which needs aggregated ingredient totals to compare against inventory.

## Technical Context

**Language/Version**: Python 3.10+ (project standard)
**Primary Dependencies**: SQLAlchemy 2.x (existing ORM)
**Storage**: SQLite with WAL mode (existing)
**Testing**: pytest (existing test infrastructure)
**Target Platform**: Desktop (CustomTkinter)
**Project Type**: Single project with layered architecture
**Performance Goals**: <1 second for 50 batch decisions
**Constraints**: Pure calculation - no database writes, deterministic results
**Scale/Scope**: Single user, ~10-50 recipes per event

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. User-Centric Design | PASS | Enables shopping list generation - direct user value |
| II. Data Integrity & FIFO | PASS | Read-only calculation, no data modification |
| III. Future-Proof Schema | PASS | Uses existing models, no schema changes |
| IV. Test-Driven Development | PASS | Will include comprehensive unit tests |
| V. Layered Architecture | PASS | Pure service layer, no UI dependencies |
| VI. Schema Change Strategy | N/A | No schema changes required |
| VII. Pragmatic Aspiration | PASS | Service layer supports future web/API wrapping |

**All gates pass. No violations to justify.**

## Project Structure

### Documentation (this feature)

```
kitty-specs/074-ingredient-aggregation/
├── spec.md              # Feature specification
├── plan.md              # This file
├── checklists/          # Quality checklists
│   └── requirements.md
└── tasks/               # Work packages (generated by /spec-kitty.tasks)
```

### Source Code (repository root)

```
src/
├── services/
│   └── ingredient_aggregation_service.py  # NEW: Core aggregation logic
├── models/
│   ├── batch_decision.py     # Existing: User batch choices
│   ├── recipe.py             # Existing: RecipeIngredient relationships
│   └── ingredient.py         # Existing: Ingredient model
└── tests/
    └── test_ingredient_aggregation_service.py  # NEW: Unit tests
```

**Structure Decision**: Add new service file following existing patterns. No changes to existing files except imports.

## Design Decisions

### D1: Service Location
**Decision**: Create `src/services/ingredient_aggregation_service.py`
**Rationale**: Separates F074 concerns from F072/F073 code in `planning_service.py`. Each feature has clear ownership.

### D2: Aggregation Key
**Decision**: Use `(ingredient_id, unit)` tuple as dictionary key
**Rationale**: Same ingredient in different units (cups vs tablespoons) must remain separate - no automatic unit conversion per spec.

### D3: Return Type
**Decision**: Return `Dict[Tuple[int, str], IngredientTotal]` where `IngredientTotal` is a dataclass
**Rationale**: Dataclass provides named fields for ingredient_id, ingredient_name, unit, total_quantity. Dictionary enables O(1) lookup for F075 integration.

### D4: Session Pattern
**Decision**: Follow CLAUDE.md session management pattern - all public functions accept `session=None`
**Rationale**: Enables transaction sharing with callers, consistent with all other services.

### D5: Precision Handling
**Decision**: Use `round(value, 3)` for final totals only
**Rationale**: Maintains precision during intermediate calculations, rounds only at output to prevent cumulative errors.

## Data Flow

```
Event (event_id)
    │
    ▼
BatchDecision[] (query by event_id)
    │
    ├── finished_unit_id → FinishedUnit → recipe_id → Recipe
    │                                                    │
    │                                                    ▼
    │                                          RecipeIngredient[]
    │                                              (ingredient_id, quantity, unit)
    │
    ▼
For each BatchDecision:
    scaled_qty = recipe_ingredient.quantity × batch_decision.batches

    ▼
Aggregate by (ingredient_id, unit):
    totals[(ingredient_id, unit)] += scaled_qty

    ▼
Return Dict[Tuple[int, str], IngredientTotal]
```

## API Design

### Public Functions

```python
@dataclass
class IngredientTotal:
    """Aggregated ingredient total for shopping list."""
    ingredient_id: int
    ingredient_name: str
    unit: str
    total_quantity: float  # Rounded to 3 decimals

def aggregate_ingredients_for_event(
    event_id: int,
    session: Session = None,
) -> Dict[Tuple[int, str], IngredientTotal]:
    """
    Aggregate ingredients across all batch decisions for an event.

    Args:
        event_id: Event to aggregate for
        session: Optional session for transaction sharing

    Returns:
        Dict keyed by (ingredient_id, unit) with IngredientTotal values

    Raises:
        ValidationError: If event not found
    """
```

### Internal Functions

```python
def _aggregate_ingredients_impl(event_id: int, session: Session) -> Dict[...]
def _scale_recipe_ingredients(recipe: Recipe, batches: int) -> List[Tuple[int, str, str, float]]
```

## Complexity Tracking

*No violations - table not needed.*

## Next Steps

Run `/spec-kitty.tasks` to generate work packages.
