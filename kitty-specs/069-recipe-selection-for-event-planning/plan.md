# Implementation Plan: Recipe Selection for Event Planning

**Branch**: `069-recipe-selection-for-event-planning` | **Date**: 2026-01-26 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/kitty-specs/069-recipe-selection-for-event-planning/spec.md`

## Summary

Implement recipe selection UI embedded in the Planning Tab that allows users to explicitly select which recipes (bases and variants) they want to make for an event. Selections persist to the existing `event_recipes` junction table from F068. Visual distinction between base recipes and variants via indentation and labels. Real-time selection count with immediate feedback.

## Technical Context

**Language/Version**: Python 3.10+
**Primary Dependencies**: CustomTkinter, SQLAlchemy 2.x
**Storage**: SQLite with WAL mode (existing database)
**Testing**: pytest with >70% service layer coverage
**Target Platform**: Desktop (Windows/Mac/Linux)
**Project Type**: Single desktop application
**Performance Goals**: Recipe list loads <2s for 100 recipes, selection count updates <100ms
**Constraints**: Must work with existing F068 data model, no schema changes required
**Scale/Scope**: Typical recipe catalog <100 recipes

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. User-Centric Design | PASS | Explicit selection honors user intent; embedded UI reduces clicks |
| II. Data Integrity | PASS | Replace (not append) ensures UI/DB consistency |
| III. Future-Proof Schema | PASS | Uses existing EventRecipe model from F068 |
| IV. Test-Driven Development | PASS | Service methods will have unit tests |
| V. Layered Architecture | PASS | UI calls service; service handles persistence |
| VI. Schema Change Strategy | PASS | No schema changes; uses existing tables |
| VII. Pragmatic Aspiration | PASS | Service layer UI-independent; supports future web migration |

**Desktop Phase Checks:**
- Does this design block web deployment? NO - Service layer is UI-independent
- Is the service layer UI-independent? YES - `set_event_recipes()` method decoupled from UI
- Does this support AI-assisted JSON import? YES - EventRecipe in import/export already
- Web migration cost? LOW - Service methods become API endpoints directly

## Project Structure

### Documentation (this feature)

```
kitty-specs/069-recipe-selection-for-event-planning/
├── plan.md              # This file
├── research.md          # Phase 0 output
├── data-model.md        # Phase 1 output
├── checklists/          # Quality checklists
└── tasks/               # Work packages (generated by /spec-kitty.tasks)
```

### Source Code (repository root)

```
src/
├── models/
│   ├── recipe.py           # Existing - base_recipe_id identifies variants
│   └── event_recipe.py     # Existing from F068 - junction table
├── services/
│   └── event_service.py    # Add recipe selection methods
├── ui/
│   └── planning_tab.py     # Modify - embed recipe selection UI
└── tests/
    └── test_recipe_selection.py  # New - service and integration tests
```

**Structure Decision**: Single project structure following existing bake-tracker layout. Recipe selection UI embedded in existing `planning_tab.py` with new service methods in `event_service.py`.

## Complexity Tracking

*No constitution violations - table not required.*

## Architecture Decisions

### AD-001: Embedded UI vs Dialog

**Decision**: Embed recipe selection as sub-section in Planning Tab (not modal dialog)

**Rationale**:
- User selected option 1 in planning discovery
- Matches "select event → configure event" mental model
- Reduces modal fatigue during planning sessions
- Keeps all event configuration visible in one view

### AD-002: Service Method Location

**Decision**: Add recipe selection methods to `event_service.py` (not new service)

**Rationale**:
- Recipe selection is event-scoped operation
- Follows F068 pattern for planning event methods
- Maintains service cohesion
- Avoids service proliferation

### AD-003: Visual Distinction Strategy

**Decision**: Use indentation (prefix) + "(variant)" label for variant recipes

**Rationale**:
- Simple to implement with CustomTkinter
- Clear visual hierarchy
- Consistent with "flat list with distinction" spec requirement
- No icons/images required

## Key Files Reference

| Component | Path | Action |
|-----------|------|--------|
| Recipe Model | `src/models/recipe.py` | Read (base_recipe_id) |
| EventRecipe Model | `src/models/event_recipe.py` | Read (existing from F068) |
| Event Service | `src/services/event_service.py` | Modify (add methods) |
| Planning Tab | `src/ui/planning_tab.py` | Modify (embed UI) |
| Recipe Service | `src/services/recipe_service.py` | Read (get_all_recipes) |
| Tests | `src/tests/test_recipe_selection.py` | Create |

## Implementation Phases

### Phase 1: Service Layer
- Add `set_event_recipes(session, event_id, recipe_ids)` to event_service
- Add `get_event_recipe_ids(session, event_id)` to event_service
- Add unit tests for service methods

### Phase 2: UI Component
- Create `RecipeSelectionFrame` widget with scrollable checkbox list
- Implement visual distinction (indent + label for variants)
- Implement real-time selection count
- Wire to service methods

### Phase 3: Integration
- Embed `RecipeSelectionFrame` in `PlanningTab`
- Show when event selected, hide when none selected
- Pre-load existing selections on event selection
- Save on explicit user action (Save button)
- Add integration tests

## Dependencies

- **F068** (Completed): Provides Event model, EventRecipe model, PlanningTab base
- **RecipeService** (Existing): Provides `get_all_recipes()` method
- **Recipe Model** (Existing): Provides `base_recipe_id` for variant identification
