# Implementation Plan: Manual Inventory Adjustments

**Branch**: `041-manual-inventory-adjustments` | **Date**: 2026-01-07 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/kitty-specs/041-manual-inventory-adjustments/spec.md`

## Summary

Add manual inventory depletion capability to track spoilage, gifts, corrections, and ad hoc usage. Creates new InventoryDepletion model for audit trail, extends enums with DepletionReason, adds manual_adjustment() service method, and provides UI dialog with live preview. **Parallel development**: Claude handles service layer + tests, Gemini handles UI.

## Technical Context

**Language/Version**: Python 3.10+
**Primary Dependencies**: SQLAlchemy 2.x, CustomTkinter
**Storage**: SQLite with WAL mode
**Testing**: pytest
**Target Platform**: Desktop (macOS, Windows)
**Project Type**: Single desktop application
**Performance Goals**: Adjustment operation < 200ms, history query < 100ms
**Constraints**: Single-user desktop app, no authentication
**Scale/Scope**: Personal use, 1 user

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Check | Status |
|-----------|-------|--------|
| I. User-Centric Design | UI intuitive for non-technical user, low friction | PASS |
| II. Data Integrity (NON-NEGOTIABLE) | FIFO integration, immutable audit records, accurate cost calculations | PASS |
| III. Future-Proof Schema | InventoryDepletion includes uuid for future distributed scenarios | PASS |
| IV. Test-Driven Development | Service layer tests required before completion | PASS |
| V. Layered Architecture (NON-NEGOTIABLE) | Service logic in service layer, UI separate | PASS |
| VI. Schema Change Strategy | Uses export/reset/import cycle (no migrations) | PASS |
| VII. Pragmatic Aspiration | Clean service layer enables future API wrapping | PASS |

**Phase-Specific Checks (Desktop Phase):**
- Does this design block web deployment? NO - service layer is UI-independent
- Is the service layer UI-independent? YES - manual_adjustment() accepts session parameter
- Does this support AI-assisted JSON import? YES - depletion records can be imported
- What's the web migration cost? LOW - service method becomes API endpoint

## Project Structure

### Documentation (this feature)

```
kitty-specs/041-manual-inventory-adjustments/
├── plan.md              # This file
├── spec.md              # Feature specification
├── research.md          # Phase 0 research decisions
├── data-model.md        # Entity definitions
├── quickstart.md        # Development guide
├── contracts/           # Service contracts
│   └── inventory_adjustment_service.py
├── research/            # Evidence trail
│   ├── evidence-log.csv
│   └── source-register.csv
└── tasks.md             # Task tracking (generated by /spec-kitty.tasks)
```

### Source Code (repository root)

```
src/
├── models/
│   ├── enums.py                    # ADD: DepletionReason enum
│   ├── inventory_depletion.py      # NEW: InventoryDepletion model
│   └── __init__.py                 # Export new model
├── services/
│   └── inventory_item_service.py   # ADD: manual_adjustment(), get_depletion_history()
├── ui/
│   ├── dialogs/
│   │   └── adjustment_dialog.py    # NEW: Manual adjustment dialog
│   └── inventory_tab.py            # ADD: [Adjust] button, wire dialog
└── tests/
    └── test_inventory_adjustment.py # NEW: Unit tests
```

**Structure Decision**: Single project structure (Option 1). Desktop application with layered architecture: UI -> Services -> Models -> Database.

## Complexity Tracking

*No Constitution violations. Feature follows established patterns.*

| Decision | Why | Simpler Alternative Rejected Because |
|----------|-----|-------------------------------------|
| New InventoryDepletion model | Audit trail for manual adjustments | Using ProductionConsumption rejected - different purpose (production vs manual) |
| Parallel development | Save Claude utilization | Sequential rejected - user requested Gemini parallel work |

## Parallel Development Plan

### Agent Responsibilities

| Agent | Scope | Files Owned | Integration Point |
|-------|-------|-------------|-------------------|
| **Claude** | Service layer, model, enum, tests | `src/models/enums.py`, `src/models/inventory_depletion.py`, `src/services/inventory_item_service.py`, `src/tests/` | Service method contract |
| **Gemini** | UI dialog, inventory tab enhancement | `src/ui/dialogs/adjustment_dialog.py`, `src/ui/inventory_tab.py` | Calls service methods |

### File Boundaries (CRITICAL)

**Claude ONLY modifies:**
- `src/models/enums.py` - Add DepletionReason enum
- `src/models/inventory_depletion.py` - NEW file
- `src/models/__init__.py` - Export new model
- `src/services/inventory_item_service.py` - Add service methods
- `src/tests/test_inventory_adjustment.py` - NEW file

**Gemini ONLY modifies:**
- `src/ui/dialogs/adjustment_dialog.py` - NEW file
- `src/ui/inventory_tab.py` - Add [Adjust] button
- `src/ui/dialogs/__init__.py` - Export new dialog (if needed)

### Task Execution Order

```
Phase 1: Claude (can start immediately)
├── Task 1.1: Create DepletionReason enum
├── Task 1.2: Create InventoryDepletion model
├── Task 1.3: Implement manual_adjustment() service method
├── Task 1.4: Implement get_depletion_history() service method
└── Task 1.5: Write unit tests

Phase 2: Gemini (can start after Task 1.1 and 1.2 complete - needs enum and model)
├── Task 2.1: Create adjustment dialog UI
├── Task 2.2: Add [Adjust] button to inventory tab
├── Task 2.3: Implement live preview calculation
└── Task 2.4: Wire dialog to service methods

Phase 3: Integration (after both phases complete)
└── Task 3.1: Integration testing - full workflow
```

### Parallelization Safety

**Safe to parallelize:**
- Tasks 1.1-1.5 (Claude) and Tasks 2.1-2.3 (Gemini) can run concurrently
- Gemini can build UI with mock data while Claude builds service

**Must be sequential:**
- Task 2.4 (wire dialog to service) requires Tasks 1.3-1.4 complete
- Task 3.1 (integration) requires both phases complete

## Key Design Decisions

### DepletionReason Enum Values

```python
class DepletionReason(str, Enum):
    # Automatic (system-generated)
    PRODUCTION = "production"
    ASSEMBLY = "assembly"

    # Manual (user-initiated)
    SPOILAGE = "spoilage"
    GIFT = "gift"
    CORRECTION = "correction"
    AD_HOC_USAGE = "ad_hoc_usage"
    OTHER = "other"
```

### Service Method Signature

```python
def manual_adjustment(
    inventory_item_id: int,
    quantity_to_deplete: Decimal,
    reason: DepletionReason,
    notes: Optional[str] = None,
    session: Optional[Session] = None,
) -> InventoryDepletion:
```

### User Identifier

Hardcoded as `"desktop-user"` for single-user desktop application. Will be parameterized when multi-user web version is implemented.

## References

- **Spec**: [spec.md](./spec.md)
- **Research**: [research.md](./research.md)
- **Data Model**: [data-model.md](./data-model.md)
- **Quickstart**: [quickstart.md](./quickstart.md)
- **Contract**: [contracts/inventory_adjustment_service.py](./contracts/inventory_adjustment_service.py)
- **Design Doc**: [docs/design/_F041_manual_inventory_adjust.md](../../docs/design/_F041_manual_inventory_adjust.md)
- **Constitution**: [.kittify/memory/constitution.md](../../.kittify/memory/constitution.md)
